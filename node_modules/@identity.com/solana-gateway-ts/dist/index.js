"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.featureExists = exports.getGatewayToken = exports.onGatewayToken = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokensForOwnerAndNetwork = exports.findGatewayTokens = void 0;
const types_1 = require("./types");
const bs58_1 = require("bs58");
const constants_1 = require("./lib/constants");
const GatewayTokenData_1 = require("./lib/GatewayTokenData");
const R = __importStar(require("ramda"));
const util_1 = require("./lib/util");
__exportStar(require("./lib/instruction"), exports);
__exportStar(require("./lib/util"), exports);
__exportStar(require("./lib/GatewayTokenData"), exports);
__exportStar(require("./lib/GatewayNetworkData"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./lib/constants"), exports);
__exportStar(require("./lib/AssignablePublicKey"), exports);
/**
 * Find all gateway tokens (optionally for a user) on a gatekeeper network, optionally filtering out revoked tokens.
 *
 * Warning - this uses the Solana getProgramAccounts RPC endpoint, which is inefficient and may be
 * blocked by some RPC services.
 *
 * @param connection A solana connection object
 * @param owner The token owner (optional)
 * @param gatekeeperNetwork The network to find a token for
 * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens
 * @param page If a large number of tokens has been issued, the request to the RPC endpoint may time out.
 * In this case, enable pagination by setting page variable
 * Pagination is not supported in the RPC API per-se, but this approximates it by
 * adding another filter on the first byte of the owner address.
 * Each page requests the accounts that match that byte.
 * @returns {Promise<GatewayToken[]>} All tokens for the owner
 */
const findGatewayTokens = (connection, owner, gatekeeperNetwork, includeRevoked = false, page) => __awaiter(void 0, void 0, void 0, function* () {
    // if owner is specified, filter on the gateway token owner
    const ownerFilter = owner
        ? {
            memcmp: {
                offset: util_1.GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,
                bytes: owner.toBase58(),
            },
        }
        : undefined;
    // filter on the gatekeeper network
    const gatekeeperNetworkFilter = {
        memcmp: {
            offset: util_1.GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,
            bytes: gatekeeperNetwork.toBase58(),
        },
    };
    const pageFilter = page !== undefined
        ? {
            memcmp: {
                offset: util_1.GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,
                bytes: (0, bs58_1.encode)([page]),
            },
        }
        : undefined;
    const filters = [ownerFilter, gatekeeperNetworkFilter, pageFilter].filter(Boolean);
    const accountsResponse = yield connection.getProgramAccounts(constants_1.PROGRAM_ID, {
        filters,
    });
    if (!accountsResponse)
        return [];
    const toGatewayToken = ({ pubkey, account, }) => (0, util_1.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);
    return accountsResponse
        .map(toGatewayToken)
        .filter((gatewayToken) => gatewayToken.state !== types_1.State.REVOKED || includeRevoked);
});
exports.findGatewayTokens = findGatewayTokens;
/**
 * Finds all gateway tokens for a user by iterating through the index seed
 * and requesting a page of addresses at a time.
 *
 * It assumes a small number of passes per GKN, so the page size by default is 5.
 * Sorts the result by active status and expiry, so unexpired active passes appear first
 * @param connection
 * @param owner
 * @param gatekeeperNetwork
 * @param includeRevoked
 * @param offset
 * @param page
 */
const findGatewayTokensForOwnerAndNetwork = (connection, owner, gatekeeperNetwork, includeRevoked = false, offset = 0, page = 5 // by default, assume a user has max five GTs for a given network
) => __awaiter(void 0, void 0, void 0, function* () {
    const addresses = yield Promise.all(R.range(offset, offset + page).map((index) => (0, util_1.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(owner, gatekeeperNetwork, index)));
    const rawAccounts = yield connection.getMultipleAccountsInfo(addresses, constants_1.SOLANA_COMMITMENT);
    return (rawAccounts
        // link the address to the account
        .map((account, index) => [
        account,
        addresses[index],
    ])
        // filter out null accounts
        .filter((tuple) => tuple[0] !== null)
        // convert to GatewayToken
        .map(([account, gatewayTokenAddress]) => (0, util_1.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress))
        // Filter out revoked GTs if requested
        .filter((gt) => gt.state !== types_1.State.REVOKED || includeRevoked)
        // sort by active status
        .sort((a, b) => (a.isValid() === b.isValid() ? 0 : a.isValid() ? -1 : 1)));
});
exports.findGatewayTokensForOwnerAndNetwork = findGatewayTokensForOwnerAndNetwork;
/**
 * Get a gateway token for the owner and network, if it exists.
 * @param connection A solana connection object
 * @param owner The token owner
 * @param gatekeeperNetwork The network to find a token for
 * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner
 */
const findGatewayToken = (connection, owner, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {
    const gatewayTokens = yield (0, exports.findGatewayTokensForOwnerAndNetwork)(connection, owner, gatekeeperNetwork);
    return gatewayTokens.length > 0 ? gatewayTokens[0] : null;
});
exports.findGatewayToken = findGatewayToken;
/**
 * Register a callback to be called whenever a gateway token changes state
 * @param connection A solana connection object
 * @param gatewayTokenAddress The address of the gateway token
 * @param callback The callback to register
 * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'
 * @return The subscription id
 */
const onGatewayTokenChange = (connection, gatewayTokenAddress, callback, commitment = constants_1.SOLANA_COMMITMENT) => {
    const accountCallback = (accountInfo) => {
        const gatewayToken = (0, util_1.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);
        callback(gatewayToken);
    };
    return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);
};
exports.onGatewayTokenChange = onGatewayTokenChange;
/**
 * Register a callback to be called whenever a gateway token is created or changes state
 * @param connection A solana connection object
 * @param owner The gateway token owner
 * @param gatekeeperNetwork
 * @param callback The callback to register
 * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'
 * @param seed
 * @return The subscription id
 */
const onGatewayToken = (connection, owner, gatekeeperNetwork, callback, commitment = constants_1.SOLANA_COMMITMENT, seed = 0) => {
    const gatewayTokenAddress = (0, util_1.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(owner, gatekeeperNetwork, seed);
    return (0, exports.onGatewayTokenChange)(connection, gatewayTokenAddress, callback, commitment);
};
exports.onGatewayToken = onGatewayToken;
/**
 * Lookup the gateway token at a given address
 * @param connection A solana connection object
 * @param gatewayTokenAddress The address of the gateway token
 */
const getGatewayToken = (connection, gatewayTokenAddress) => __awaiter(void 0, void 0, void 0, function* () {
    const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);
    if (!account)
        return null;
    return (0, util_1.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);
});
exports.getGatewayToken = getGatewayToken;
/**
 * Return true if an address feature exists.
 * @param connection
 * @param feature The feature to check
 * @param network The gatekeeper network
 */
const featureExists = (connection, feature, network) => __awaiter(void 0, void 0, void 0, function* () {
    const featureAccountAddress = (0, util_1.getFeatureAccountAddress)(feature, network);
    const account = yield connection.getAccountInfo(featureAccountAddress, constants_1.SOLANA_COMMITMENT);
    return account != null && constants_1.PROGRAM_ID.equals(account.owner);
});
exports.featureExists = featureExists;
//# sourceMappingURL=index.js.map