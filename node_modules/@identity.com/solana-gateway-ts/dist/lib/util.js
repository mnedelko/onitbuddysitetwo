"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFeatureAccountAddress = exports.numToBuffer = exports.gatekeeperExists = exports.removeAccountChangeListener = exports.dataToGatewayToken = exports.GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = exports.GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = exports.getGatekeeperAccountAddress = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
const types_1 = require("../types");
const GatewayNetworkData_1 = require("./GatewayNetworkData");
/**
 * Derive the address of the gatekeeper PDA for this gatekeeper
 * @param authority The gatekeeper
 * @param network The network
 */
const getGatekeeperAccountAddress = (authority, network) => web3_js_1.PublicKey.findProgramAddressSync([
    authority.toBuffer(),
    network.toBuffer(),
    Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, "utf8"),
], constants_1.PROGRAM_ID)[0];
exports.getGatekeeperAccountAddress = getGatekeeperAccountAddress;
/**
 * Derive the address of the gateway token PDA for this owner address and optional seed.
 * @param owner The owner of the gateway token
 * @param gatekeeperNetwork The network of the gateway token
 * @param index The index of the gateway token (default 0)
 */
const getGatewayTokenAddressForOwnerAndGatekeeperNetwork = (owner, gatekeeperNetwork, index = 0) => {
    // The index is converted to an 8-byte uint array. Ensure no overflow here.
    if (index > Math.pow(2, (8 * 8))) {
        throw new Error("index must be < max(8 bytes) when calling getGatewayTokenAddressForOwnerAndGatekeeperNetwork.");
    }
    const seed = (0, exports.numToBuffer)(index);
    const paddedSeed = Buffer.concat([Buffer.alloc(8 - seed.length, 0), seed]);
    if (paddedSeed.length > 8) {
        throw new Error("Seed has length " +
            paddedSeed.length +
            " instead of 8 when calling getGatewayTokenAddressForOwnerAndGatekeeperNetwork.");
    }
    const seeds = [
        owner.toBuffer(),
        Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, "utf8"),
        paddedSeed,
        gatekeeperNetwork.toBuffer(),
    ];
    return web3_js_1.PublicKey.findProgramAddressSync(seeds, constants_1.PROGRAM_ID)[0];
};
exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = getGatewayTokenAddressForOwnerAndGatekeeperNetwork;
// Based on solana/integration-lib/src/state.rs
// If the optional the parent-gateway-token field is populated, this value will be
// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put
// all optional values at the end of the struct to simplify account parsing a little
exports.GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2;
// As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this
exports.GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;
function fromGatewayTokenState(state) {
    if (!!state.active)
        return types_1.State.ACTIVE;
    if (!!state.revoked)
        return types_1.State.REVOKED;
    if (!!state.frozen)
        return types_1.State.FROZEN;
    throw new Error("Unrecognised state " + JSON.stringify(state));
}
const dataToGatewayToken = (data, publicKey) => {
    var _a;
    return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());
};
exports.dataToGatewayToken = dataToGatewayToken;
/**
 * Stops listening to gateway state changes
 * @param connection A solana connection object
 * @param id The subscription id to deregister
 */
const removeAccountChangeListener = (connection, id) => connection.removeAccountChangeListener(id);
exports.removeAccountChangeListener = removeAccountChangeListener;
/**
 * Returns whether or not a gatekeeper exists from a network and authority
 * @param connection A solana connection
 * @param gatekeeperAuthority The authority of the gatekeeper
 * @param gatekeeperNetwork The network of the gatekeeper
 */
const gatekeeperExists = (connection, gatekeeperAuthority, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {
    const gatekeeperAccount = (0, exports.getGatekeeperAccountAddress)(gatekeeperAuthority, gatekeeperNetwork);
    const account = yield connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);
    return account != null && constants_1.PROGRAM_ID.equals(account.owner);
});
exports.gatekeeperExists = gatekeeperExists;
/**
 * Converts a number to a buffer of U8 integers, for use in the gateway token address
 * derivation as the seed value.
 * @param num
 */
const numToBuffer = (num) => {
    const numToArray = (num, arr) => {
        if (num === 0)
            return arr;
        arr.unshift(num % 256);
        return numToArray(Math.floor(num / 256), arr);
    };
    if (num < 0)
        throw new Error("Cannot convert negative number to buffer");
    if (Number.isNaN(num))
        throw new Error("Cannot convert NaN to buffer");
    if (num === 0)
        return Buffer.from([0]);
    return Buffer.from(numToArray(num, []));
};
exports.numToBuffer = numToBuffer;
/**
 * Derive the address of the feature PDA
 * @param feature The feature to set.
 * @param network The network
 */
const getFeatureAccountAddress = (feature, network) => {
    const featureName = (0, GatewayNetworkData_1.mapEnumToFeatureName)(feature.enum);
    return web3_js_1.PublicKey.findProgramAddressSync([network.toBytes(), Buffer.from(featureName, "utf8")], constants_1.PROGRAM_ID)[0];
};
exports.getFeatureAccountAddress = getFeatureAccountAddress;
//# sourceMappingURL=util.js.map