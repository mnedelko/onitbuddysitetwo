{"ast":null,"code":"import _toConsumableArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    var variantSizes = idlAccount.type.variants.map(function (variant) {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n      return variant.fields\n      // @ts-ignore\n      .map(function (f) {\n        // @ts-ignore\n        if (f.name === undefined) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        }\n        // @ts-ignore\n        return typeSize(idl, f.type);\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n    });\n    return Math.max.apply(Math, _toConsumableArray(variantSizes)) + 1;\n  }\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n  return idlAccount.type.fields.map(function (f) {\n    return typeSize(idl, f.type);\n  }).reduce(function (a, b) {\n    return a + b;\n  });\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n    case \"u8\":\n      return 1;\n    case \"i8\":\n      return 1;\n    case \"i16\":\n      return 2;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    case \"i32\":\n      return 4;\n    case \"u64\":\n      return 8;\n    case \"i64\":\n      return 8;\n    case \"u128\":\n      return 16;\n    case \"i128\":\n      return 16;\n    case \"bytes\":\n      return 1;\n    case \"string\":\n      return 1;\n    case \"publicKey\":\n      return 32;\n    default:\n      // @ts-ignore\n      if (ty.vec !== undefined) {\n        return 1;\n      }\n      // @ts-ignore\n      if (ty.option !== undefined) {\n        // @ts-ignore\n        return 1 + typeSize(idl, ty.option);\n      }\n      // @ts-ignore\n      if (ty.defined !== undefined) {\n        // @ts-ignore\n        var filtered = idl.types.filter(function (t) {\n          return t.name === ty.defined;\n        });\n        if (filtered.length !== 1) {\n          throw new IdlError(\"Type not found: \".concat(JSON.stringify(ty)));\n        }\n        var typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      }\n      // @ts-ignore\n      if (ty.array !== undefined) {\n        // @ts-ignore\n        var arrayTy = ty.array[0];\n        // @ts-ignore\n        var arraySize = ty.array[1];\n        // @ts-ignore\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n      throw new Error(\"Invalid type \".concat(JSON.stringify(ty)));\n  }\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace, ixName) {\n  var name = snakeCase(ixName);\n  var preimage = \"\".concat(nameSpace, \":\").concat(name);\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"sources":["../../../src/coder/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n    if (idlAccount.type.kind === \"enum\") {\n        let variantSizes = idlAccount.type.variants.map((variant) => {\n            if (variant.fields === undefined) {\n                return 0;\n            }\n            return (variant.fields\n                // @ts-ignore\n                .map((f) => {\n                // @ts-ignore\n                if (f.name === undefined) {\n                    throw new Error(\"Tuple enum variants not yet implemented.\");\n                }\n                // @ts-ignore\n                return typeSize(idl, f.type);\n            })\n                .reduce((a, b) => a + b));\n        });\n        return Math.max(...variantSizes) + 1;\n    }\n    if (idlAccount.type.fields === undefined) {\n        return 0;\n    }\n    return idlAccount.type.fields\n        .map((f) => typeSize(idl, f.type))\n        .reduce((a, b) => a + b);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n    switch (ty) {\n        case \"bool\":\n            return 1;\n        case \"u8\":\n            return 1;\n        case \"i8\":\n            return 1;\n        case \"i16\":\n            return 2;\n        case \"u16\":\n            return 2;\n        case \"u32\":\n            return 4;\n        case \"i32\":\n            return 4;\n        case \"u64\":\n            return 8;\n        case \"i64\":\n            return 8;\n        case \"u128\":\n            return 16;\n        case \"i128\":\n            return 16;\n        case \"bytes\":\n            return 1;\n        case \"string\":\n            return 1;\n        case \"publicKey\":\n            return 32;\n        default:\n            // @ts-ignore\n            if (ty.vec !== undefined) {\n                return 1;\n            }\n            // @ts-ignore\n            if (ty.option !== undefined) {\n                // @ts-ignore\n                return 1 + typeSize(idl, ty.option);\n            }\n            // @ts-ignore\n            if (ty.defined !== undefined) {\n                // @ts-ignore\n                const filtered = idl.types.filter((t) => t.name === ty.defined);\n                if (filtered.length !== 1) {\n                    throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n                }\n                let typeDef = filtered[0];\n                return accountSize(idl, typeDef);\n            }\n            // @ts-ignore\n            if (ty.array !== undefined) {\n                // @ts-ignore\n                let arrayTy = ty.array[0];\n                // @ts-ignore\n                let arraySize = ty.array[1];\n                // @ts-ignore\n                return typeSize(idl, arrayTy) * arraySize;\n            }\n            throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n    }\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace, ixName) {\n    let name = snakeCase(ixName);\n    let preimage = `${nameSpace}:${name}`;\n    return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}