{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { inflate } from \"pako\";\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventManager } from \"./event\";\nimport { translateAddress } from \"./common\";\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/project-serum/anchor#examples).\n */\nexport var Program = /*#__PURE__*/function () {\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  function Program(idl, programId, provider) {\n    _classCallCheck(this, Program);\n    programId = translateAddress(programId);\n    // Fields.\n    this._idl = idl;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = new Coder(idl);\n    this._events = new EventManager(this._programId, this._provider, this._coder);\n    // Dynamic namespaces.\n    var _NamespaceFactory$bui = NamespaceFactory.build(idl, this._coder, programId, this._provider),\n      _NamespaceFactory$bui2 = _slicedToArray(_NamespaceFactory$bui, 6),\n      rpc = _NamespaceFactory$bui2[0],\n      instruction = _NamespaceFactory$bui2[1],\n      transaction = _NamespaceFactory$bui2[2],\n      account = _NamespaceFactory$bui2[3],\n      simulate = _NamespaceFactory$bui2[4],\n      state = _NamespaceFactory$bui2[5];\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.state = state;\n  }\n  /**\n   * Address of the program.\n   */\n  _createClass(Program, [{\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\n     * IDL defining the program's interface.\n     */\n  }, {\n    key: \"idl\",\n    get: function get() {\n      return this._idl;\n    }\n    /**\n     * Coder for serializing requests.\n     */\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n    /**\n     * Wallet and network provider.\n     */\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\n     * Generates a Program client by fetching the IDL from the network.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n  }, {\n    key: \"addEventListener\",\n    value:\n    /**\n     * Invokes the given callback every time the given event is emitted.\n     *\n     * @param eventName The PascalCase name of the event, provided by the IDL.\n     * @param callback  The function to invoke whenever the event is emitted from\n     *                  program logs.\n     */\n    function addEventListener(eventName, callback) {\n      return this._events.addEventListener(eventName, callback);\n    }\n    /**\n     * Unsubscribes from the given eventName.\n     */\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(listener) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._events.removeEventListener(listener);\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function removeEventListener(_x) {\n        return _removeEventListener.apply(this, arguments);\n      }\n      return removeEventListener;\n    }()\n  }], [{\n    key: \"at\",\n    value: function () {\n      var _at = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address, provider) {\n        var programId, idl;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                programId = translateAddress(address);\n                _context2.next = 3;\n                return Program.fetchIdl(programId, provider);\n              case 3:\n                idl = _context2.sent;\n                return _context2.abrupt(\"return\", new Program(idl, programId, provider));\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function at(_x2, _x3) {\n        return _at.apply(this, arguments);\n      }\n      return at;\n    }()\n    /**\n     * Fetches an idl from the blockchain.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n  }, {\n    key: \"fetchIdl\",\n    value: function () {\n      var _fetchIdl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address, provider) {\n        var programId, idlAddr, accountInfo, idlAccount, inflatedIdl;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                provider = provider !== null && provider !== void 0 ? provider : getProvider();\n                programId = translateAddress(address);\n                _context3.next = 4;\n                return idlAddress(programId);\n              case 4:\n                idlAddr = _context3.sent;\n                _context3.next = 7;\n                return provider.connection.getAccountInfo(idlAddr);\n              case 7:\n                accountInfo = _context3.sent;\n                // Chop off account discriminator.\n                idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n                inflatedIdl = inflate(idlAccount.data);\n                return _context3.abrupt(\"return\", JSON.parse(utf8.decode(inflatedIdl)));\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function fetchIdl(_x4, _x5) {\n        return _fetchIdl.apply(this, arguments);\n      }\n      return fetchIdl;\n    }()\n  }]);\n  return Program;\n}();","map":{"version":3,"sources":["../../../src/program/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { inflate } from \"pako\";\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventManager } from \"./event\";\nimport { translateAddress } from \"./common\";\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/project-serum/anchor#examples).\n */\nexport class Program {\n    /**\n     * @param idl       The interface definition.\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context to use. If not provided\n     *                  then uses [[getProvider]].\n     */\n    constructor(idl, programId, provider) {\n        programId = translateAddress(programId);\n        // Fields.\n        this._idl = idl;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = new Coder(idl);\n        this._events = new EventManager(this._programId, this._provider, this._coder);\n        // Dynamic namespaces.\n        const [rpc, instruction, transaction, account, simulate, state,] = NamespaceFactory.build(idl, this._coder, programId, this._provider);\n        this.rpc = rpc;\n        this.instruction = instruction;\n        this.transaction = transaction;\n        this.account = account;\n        this.simulate = simulate;\n        this.state = state;\n    }\n    /**\n     * Address of the program.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * IDL defining the program's interface.\n     */\n    get idl() {\n        return this._idl;\n    }\n    /**\n     * Coder for serializing requests.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Generates a Program client by fetching the IDL from the network.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n    static async at(address, provider) {\n        const programId = translateAddress(address);\n        const idl = await Program.fetchIdl(programId, provider);\n        return new Program(idl, programId, provider);\n    }\n    /**\n     * Fetches an idl from the blockchain.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n    static async fetchIdl(address, provider) {\n        provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        const programId = translateAddress(address);\n        const idlAddr = await idlAddress(programId);\n        const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n        // Chop off account discriminator.\n        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n        const inflatedIdl = inflate(idlAccount.data);\n        return JSON.parse(utf8.decode(inflatedIdl));\n    }\n    /**\n     * Invokes the given callback every time the given event is emitted.\n     *\n     * @param eventName The PascalCase name of the event, provided by the IDL.\n     * @param callback  The function to invoke whenever the event is emitted from\n     *                  program logs.\n     */\n    addEventListener(eventName, callback) {\n        return this._events.addEventListener(eventName, callback);\n    }\n    /**\n     * Unsubscribes from the given eventName.\n     */\n    async removeEventListener(listener) {\n        return await this._events.removeEventListener(listener);\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}