{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport BN from \"bn.js\";\nimport { sha256 as sha256Sync } from \"js-sha256\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\";\n// Sync version of web3.PublicKey.createWithSeed.\nexport function createWithSeedSync(fromPublicKey, seed, programId) {\n  var buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);\n  var hash = sha256Sync.digest(buffer);\n  return new PublicKey(Buffer.from(hash));\n}\n// Sync version of web3.PublicKey.createProgramAddress.\nexport function createProgramAddressSync(seeds, programId) {\n  var MAX_SEED_LENGTH = 32;\n  var buffer = Buffer.alloc(0);\n  seeds.forEach(function (seed) {\n    if (seed.length > MAX_SEED_LENGTH) {\n      throw new TypeError(\"Max seed length exceeded\");\n    }\n    buffer = Buffer.concat([buffer, toBuffer(seed)]);\n  });\n  buffer = Buffer.concat([buffer, programId.toBuffer(), Buffer.from(\"ProgramDerivedAddress\")]);\n  var hash = sha256Sync(new Uint8Array(buffer));\n  var publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n  if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n    throw new Error(\"Invalid seeds, address must fall off the curve\");\n  }\n  return new PublicKey(publicKeyBytes);\n}\n// Sync version of web3.PublicKey.findProgramAddress.\nexport function findProgramAddressSync(seeds, programId) {\n  var nonce = 255;\n  var address;\n  while (nonce != 0) {\n    try {\n      var seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n      address = createProgramAddressSync(seedsWithNonce, programId);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw err;\n      }\n      nonce--;\n      continue;\n    }\n    return [address, nonce];\n  }\n  throw new Error(\"Unable to find a viable program address nonce\");\n}\nvar toBuffer = function toBuffer(arr) {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\nexport function associated(_x) {\n  return _associated.apply(this, arguments);\n}\nfunction _associated() {\n  _associated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(programId) {\n    var seeds,\n      _len,\n      args,\n      _key,\n      _yield$PublicKey$find,\n      _yield$PublicKey$find2,\n      assoc,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n            for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = _args[_key];\n            }\n            args.forEach(function (arg) {\n              seeds.push(\n              // @ts-ignore\n              arg.buffer !== undefined ? arg : translateAddress(arg).toBuffer());\n            });\n            _context.next = 5;\n            return PublicKey.findProgramAddress(seeds, translateAddress(programId));\n          case 5:\n            _yield$PublicKey$find = _context.sent;\n            _yield$PublicKey$find2 = _slicedToArray(_yield$PublicKey$find, 1);\n            assoc = _yield$PublicKey$find2[0];\n            return _context.abrupt(\"return\", assoc);\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _associated.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/utils/pubkey.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import BN from \"bn.js\";\nimport { sha256 as sha256Sync } from \"js-sha256\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\";\n// Sync version of web3.PublicKey.createWithSeed.\nexport function createWithSeedSync(fromPublicKey, seed, programId) {\n    const buffer = Buffer.concat([\n        fromPublicKey.toBuffer(),\n        Buffer.from(seed),\n        programId.toBuffer(),\n    ]);\n    const hash = sha256Sync.digest(buffer);\n    return new PublicKey(Buffer.from(hash));\n}\n// Sync version of web3.PublicKey.createProgramAddress.\nexport function createProgramAddressSync(seeds, programId) {\n    const MAX_SEED_LENGTH = 32;\n    let buffer = Buffer.alloc(0);\n    seeds.forEach(function (seed) {\n        if (seed.length > MAX_SEED_LENGTH) {\n            throw new TypeError(`Max seed length exceeded`);\n        }\n        buffer = Buffer.concat([buffer, toBuffer(seed)]);\n    });\n    buffer = Buffer.concat([\n        buffer,\n        programId.toBuffer(),\n        Buffer.from(\"ProgramDerivedAddress\"),\n    ]);\n    let hash = sha256Sync(new Uint8Array(buffer));\n    let publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n    if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n        throw new Error(`Invalid seeds, address must fall off the curve`);\n    }\n    return new PublicKey(publicKeyBytes);\n}\n// Sync version of web3.PublicKey.findProgramAddress.\nexport function findProgramAddressSync(seeds, programId) {\n    let nonce = 255;\n    let address;\n    while (nonce != 0) {\n        try {\n            const seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n            address = createProgramAddressSync(seedsWithNonce, programId);\n        }\n        catch (err) {\n            if (err instanceof TypeError) {\n                throw err;\n            }\n            nonce--;\n            continue;\n        }\n        return [address, nonce];\n    }\n    throw new Error(`Unable to find a viable program address nonce`);\n}\nconst toBuffer = (arr) => {\n    if (arr instanceof Buffer) {\n        return arr;\n    }\n    else if (arr instanceof Uint8Array) {\n        return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    }\n    else {\n        return Buffer.from(arr);\n    }\n};\nexport async function associated(programId, ...args) {\n    let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n    args.forEach((arg) => {\n        seeds.push(\n        // @ts-ignore\n        arg.buffer !== undefined ? arg : translateAddress(arg).toBuffer());\n    });\n    const [assoc] = await PublicKey.findProgramAddress(seeds, translateAddress(programId));\n    return assoc;\n}\n//# sourceMappingURL=pubkey.js.map"]},"metadata":{},"sourceType":"module"}