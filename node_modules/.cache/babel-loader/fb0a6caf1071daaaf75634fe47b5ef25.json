{"ast":null,"code":"import _toConsumableArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as assert from \"assert\";\nvar LOG_START_INDEX = \"Program log: \".length;\nexport var EventManager = /*#__PURE__*/function () {\n  function EventManager(programId, provider, coder) {\n    _classCallCheck(this, EventManager);\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n  _createClass(EventManager, [{\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, callback) {\n      var _this = this;\n      var listener = this._listenerIdCount;\n      this._listenerIdCount += 1;\n      // Store the listener into the event map.\n      if (!(eventName in this._eventCallbacks)) {\n        this._eventListeners.set(eventName, []);\n      }\n      this._eventListeners.set(eventName, this._eventListeners.get(eventName).concat(listener));\n      // Store the callback into the listener map.\n      this._eventCallbacks.set(listener, [eventName, callback]);\n      // Create the subscription singleton, if needed.\n      if (this._onLogsSubscriptionId !== undefined) {\n        return listener;\n      }\n      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, function (logs, ctx) {\n        if (logs.err) {\n          console.error(logs);\n          return;\n        }\n        _this._eventParser.parseLogs(logs.logs, function (event) {\n          var allListeners = _this._eventListeners.get(event.name);\n          if (allListeners) {\n            allListeners.forEach(function (listener) {\n              var _this$_eventCallbacks = _this._eventCallbacks.get(listener),\n                _this$_eventCallbacks2 = _slicedToArray(_this$_eventCallbacks, 2),\n                callback = _this$_eventCallbacks2[1];\n              callback(event.data, ctx.slot);\n            });\n          }\n        });\n      });\n      return listener;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(listener) {\n        var callback, _callback, eventName, listeners;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Get the callback.\n                callback = this._eventCallbacks.get(listener);\n                if (callback) {\n                  _context.next = 3;\n                  break;\n                }\n                throw new Error(\"Event listener \".concat(listener, \" doesn't exist!\"));\n              case 3:\n                _callback = _slicedToArray(callback, 1), eventName = _callback[0]; // Get the listeners.\n                listeners = this._eventListeners.get(eventName);\n                if (listeners) {\n                  _context.next = 7;\n                  break;\n                }\n                throw new Error(\"Event listeners don't exist for \".concat(eventName, \"!\"));\n              case 7:\n                // Update both maps.\n                this._eventCallbacks.delete(listener);\n                listeners = listeners.filter(function (l) {\n                  return l !== listener;\n                });\n                if (listeners.length === 0) {\n                  this._eventListeners.delete(eventName);\n                }\n                // Kill the websocket connection if all listeners have been removed.\n                if (!(this._eventCallbacks.size == 0)) {\n                  _context.next = 15;\n                  break;\n                }\n                assert.ok(this._eventListeners.size === 0);\n                _context.next = 14;\n                return this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n              case 14:\n                this._onLogsSubscriptionId = undefined;\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function removeEventListener(_x) {\n        return _removeEventListener.apply(this, arguments);\n      }\n      return removeEventListener;\n    }()\n  }]);\n  return EventManager;\n}();\nexport var EventParser = /*#__PURE__*/function () {\n  function EventParser(programId, coder) {\n    _classCallCheck(this, EventParser);\n    this.coder = coder;\n    this.programId = programId;\n  }\n  // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n  _createClass(EventParser, [{\n    key: \"parseLogs\",\n    value: function parseLogs(logs, callback) {\n      var logScanner = new LogScanner(logs);\n      var execution = new ExecutionContext(logScanner.next());\n      var log = logScanner.next();\n      while (log !== null) {\n        var _this$handleLog = this.handleLog(execution, log),\n          _this$handleLog2 = _slicedToArray(_this$handleLog, 3),\n          event = _this$handleLog2[0],\n          newProgram = _this$handleLog2[1],\n          didPop = _this$handleLog2[2];\n        if (event) {\n          callback(event);\n        }\n        if (newProgram) {\n          execution.push(newProgram);\n        }\n        if (didPop) {\n          execution.pop();\n        }\n        log = logScanner.next();\n      }\n    }\n    // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n  }, {\n    key: \"handleLog\",\n    value: function handleLog(execution, log) {\n      // Executing program is this program.\n      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n        return this.handleProgramLog(log);\n      }\n      // Executing program is not this program.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    }\n    // Handles logs from *this* program.\n  }, {\n    key: \"handleProgramLog\",\n    value: function handleProgramLog(log) {\n      // This is a `msg!` log.\n      if (log.startsWith(\"Program log:\")) {\n        var logStr = log.slice(LOG_START_INDEX);\n        var event = this.coder.events.decode(logStr);\n        return [event, null, false];\n      }\n      // System log.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    }\n    // Handles logs when the current program being executing is *not* this.\n  }, {\n    key: \"handleSystemLog\",\n    value: function handleSystemLog(log) {\n      // System component.\n      var logStart = log.split(\":\")[0];\n      // Did the program finish executing?\n      if (logStart.match(/^Program (.*) success/g) !== null) {\n        return [null, true];\n        // Recursive call.\n      } else if (logStart.startsWith(\"Program \".concat(this.programId.toString(), \" invoke\"))) {\n        return [this.programId.toString(), false];\n      }\n      // CPI call.\n      else if (logStart.includes(\"invoke\")) {\n        return [\"cpi\", false]; // Any string will do.\n      } else {\n        return [null, false];\n      }\n    }\n  }]);\n  return EventParser;\n}();\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nvar ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext(log) {\n    _classCallCheck(this, ExecutionContext);\n    // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n    var program = /^Program (.*) invoke.*$/g.exec(log)[1];\n    this.stack = [program];\n  }\n  _createClass(ExecutionContext, [{\n    key: \"program\",\n    value: function program() {\n      assert.ok(this.stack.length > 0);\n      return this.stack[this.stack.length - 1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(newProgram) {\n      this.stack.push(newProgram);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert.ok(this.stack.length > 0);\n      this.stack.pop();\n    }\n  }]);\n  return ExecutionContext;\n}();\nvar LogScanner = /*#__PURE__*/function () {\n  function LogScanner(logs) {\n    _classCallCheck(this, LogScanner);\n    this.logs = logs;\n  }\n  _createClass(LogScanner, [{\n    key: \"next\",\n    value: function next() {\n      if (this.logs.length === 0) {\n        return null;\n      }\n      var l = this.logs[0];\n      this.logs = this.logs.slice(1);\n      return l;\n    }\n  }]);\n  return LogScanner;\n}();","map":{"version":3,"sources":["../../../src/program/event.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as assert from \"assert\";\nconst LOG_START_INDEX = \"Program log: \".length;\nexport class EventManager {\n    constructor(programId, provider, coder) {\n        this._programId = programId;\n        this._provider = provider;\n        this._eventParser = new EventParser(programId, coder);\n        this._eventCallbacks = new Map();\n        this._eventListeners = new Map();\n        this._listenerIdCount = 0;\n    }\n    addEventListener(eventName, callback) {\n        let listener = this._listenerIdCount;\n        this._listenerIdCount += 1;\n        // Store the listener into the event map.\n        if (!(eventName in this._eventCallbacks)) {\n            this._eventListeners.set(eventName, []);\n        }\n        this._eventListeners.set(eventName, this._eventListeners.get(eventName).concat(listener));\n        // Store the callback into the listener map.\n        this._eventCallbacks.set(listener, [eventName, callback]);\n        // Create the subscription singleton, if needed.\n        if (this._onLogsSubscriptionId !== undefined) {\n            return listener;\n        }\n        this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n            if (logs.err) {\n                console.error(logs);\n                return;\n            }\n            this._eventParser.parseLogs(logs.logs, (event) => {\n                const allListeners = this._eventListeners.get(event.name);\n                if (allListeners) {\n                    allListeners.forEach((listener) => {\n                        const [, callback] = this._eventCallbacks.get(listener);\n                        callback(event.data, ctx.slot);\n                    });\n                }\n            });\n        });\n        return listener;\n    }\n    async removeEventListener(listener) {\n        // Get the callback.\n        const callback = this._eventCallbacks.get(listener);\n        if (!callback) {\n            throw new Error(`Event listener ${listener} doesn't exist!`);\n        }\n        const [eventName] = callback;\n        // Get the listeners.\n        let listeners = this._eventListeners.get(eventName);\n        if (!listeners) {\n            throw new Error(`Event listeners don't exist for ${eventName}!`);\n        }\n        // Update both maps.\n        this._eventCallbacks.delete(listener);\n        listeners = listeners.filter((l) => l !== listener);\n        if (listeners.length === 0) {\n            this._eventListeners.delete(eventName);\n        }\n        // Kill the websocket connection if all listeners have been removed.\n        if (this._eventCallbacks.size == 0) {\n            assert.ok(this._eventListeners.size === 0);\n            await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n            this._onLogsSubscriptionId = undefined;\n        }\n    }\n}\nexport class EventParser {\n    constructor(programId, coder) {\n        this.coder = coder;\n        this.programId = programId;\n    }\n    // Each log given, represents an array of messages emitted by\n    // a single transaction, which can execute many different programs across\n    // CPI boundaries. However, the subscription is only interested in the\n    // events emitted by *this* program. In achieving this, we keep track of the\n    // program execution context by parsing each log and looking for a CPI\n    // `invoke` call. If one exists, we know a new program is executing. So we\n    // push the programId onto a stack and switch the program context. This\n    // allows us to track, for a given log, which program was executing during\n    // its emission, thereby allowing us to know if a given log event was\n    // emitted by *this* program. If it was, then we parse the raw string and\n    // emit the event if the string matches the event being subscribed to.\n    parseLogs(logs, callback) {\n        const logScanner = new LogScanner(logs);\n        const execution = new ExecutionContext(logScanner.next());\n        let log = logScanner.next();\n        while (log !== null) {\n            let [event, newProgram, didPop] = this.handleLog(execution, log);\n            if (event) {\n                callback(event);\n            }\n            if (newProgram) {\n                execution.push(newProgram);\n            }\n            if (didPop) {\n                execution.pop();\n            }\n            log = logScanner.next();\n        }\n    }\n    // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n    handleLog(execution, log) {\n        // Executing program is this program.\n        if (execution.stack.length > 0 &&\n            execution.program() === this.programId.toString()) {\n            return this.handleProgramLog(log);\n        }\n        // Executing program is not this program.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs from *this* program.\n    handleProgramLog(log) {\n        // This is a `msg!` log.\n        if (log.startsWith(\"Program log:\")) {\n            const logStr = log.slice(LOG_START_INDEX);\n            const event = this.coder.events.decode(logStr);\n            return [event, null, false];\n        }\n        // System log.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs when the current program being executing is *not* this.\n    handleSystemLog(log) {\n        // System component.\n        const logStart = log.split(\":\")[0];\n        // Did the program finish executing?\n        if (logStart.match(/^Program (.*) success/g) !== null) {\n            return [null, true];\n            // Recursive call.\n        }\n        else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n            return [this.programId.toString(), false];\n        }\n        // CPI call.\n        else if (logStart.includes(\"invoke\")) {\n            return [\"cpi\", false]; // Any string will do.\n        }\n        else {\n            return [null, false];\n        }\n    }\n}\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n    constructor(log) {\n        // Assumes the first log in every transaction is an `invoke` log from the\n        // runtime.\n        const program = /^Program (.*) invoke.*$/g.exec(log)[1];\n        this.stack = [program];\n    }\n    program() {\n        assert.ok(this.stack.length > 0);\n        return this.stack[this.stack.length - 1];\n    }\n    push(newProgram) {\n        this.stack.push(newProgram);\n    }\n    pop() {\n        assert.ok(this.stack.length > 0);\n        this.stack.pop();\n    }\n}\nclass LogScanner {\n    constructor(logs) {\n        this.logs = logs;\n    }\n    next() {\n        if (this.logs.length === 0) {\n            return null;\n        }\n        let l = this.logs[0];\n        this.logs = this.logs.slice(1);\n        return l;\n    }\n}\n//# sourceMappingURL=event.js.map"]},"metadata":{},"sourceType":"module"}