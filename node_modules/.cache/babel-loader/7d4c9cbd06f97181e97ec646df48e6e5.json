{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\nvar R = __importStar(require(\"ramda\"));\nvar react_1 = require(\"react\");\nvar utils_1 = require(\"../useReducer/utils\");\nvar logger_1 = __importDefault(require(\"../logger\"));\nvar types_1 = require(\"../types\");\nvar tokenUtils_1 = require(\"../utils/tokenUtils\");\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED\n        });\n      }\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          refreshTimeoutId: undefined,\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.CHECKING\n        });\n      }\n    case 'refresh_clear_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: undefined\n      });\n    case 'refresh_set_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: action.refreshTimeoutId\n      });\n    case 'refresh_token_success':\n      return Object.assign(Object.assign({}, state), {\n        refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN\n      });\n    default:\n      return state;\n  }\n};\nexports.reducer = reducer;\nvar useRefresh = function useRefresh(_ref, state, dispatch) {\n  var stage = _ref.stage,\n    gatekeeperClient = _ref.gatekeeperClient,\n    networkConfig = _ref.networkConfig;\n  var refreshTimeoutId = state.refreshTimeoutId,\n    gatewayToken = state.gatewayToken,\n    gatekeeperNetworkAddress = state.gatekeeperNetworkAddress,\n    ownerSigns = state.ownerSigns,\n    walletAddress = state.walletAddress;\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useRefresh] \".concat(message), obj);\n  };\n  var setTimeoutForRefresh = (0, react_1.useRef)(null);\n  /**\n   * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n   * event, triggering the refreshFlow\n   */\n  var checkForRefreshWithTimeout = (0, react_1.useCallback)(function () {\n    logDebug('Checking if refresh required', refreshTimeoutId);\n    dispatch({\n      type: 'refresh_status_check'\n    });\n    if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n      var tokenExpirationMarginSeconds = networkConfig.tokenExpirationMarginSeconds;\n      var checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n      var timeoutId = setTimeout(function () {\n        var shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n        if (shouldRefresh) {\n          logDebug('Refreshing Gateway Token');\n          dispatch({\n            type: 'refresh_start'\n          });\n          dispatch({\n            type: 'civicPass_check_token_status'\n          });\n          return;\n        }\n        logDebug('Skipping refresh', {\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n        dispatch({\n          type: 'refresh_complete'\n        });\n      }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n      logDebug('Setting token refresh timeout', {\n        expiring: gatewayToken.expiryTime,\n        checkForExpirationIntervalMilliseconds: checkForExpirationIntervalMilliseconds,\n        margin: tokenExpirationMarginSeconds\n      });\n      dispatch({\n        type: 'refresh_set_timeout',\n        refreshTimeoutId: timeoutId\n      });\n    }\n  }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n  var refreshToken = (0, react_1.useCallback)(function (useWallet) {\n    return /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {\n        var proof, payload, refreshResult;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                proof = _ref2.proof, payload = _ref2.payload;\n                logDebug('Refresh token', {\n                  payload: payload,\n                  proof: proof\n                });\n                dispatch({\n                  type: 'refresh_with_powo_in_progress'\n                });\n                _context.next = 5;\n                return gatekeeperClient().refreshToken({\n                  wallet: useWallet,\n                  payload: payload,\n                  proof: proof,\n                  ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false\n                });\n              case 5:\n                refreshResult = _context.sent;\n                if (!(refreshResult.status >= 400 && refreshResult.status < 500)) {\n                  _context.next = 8;\n                  break;\n                }\n                throw new Error(\"Error \".concat(refreshResult.status, \" from refresh gatekeeper token request\"));\n              case 8:\n                if (!(ownerSigns && (R.isNil(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction) || R.isEmpty(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction)))) {\n                  _context.next = 10;\n                  break;\n                }\n                throw new Error(\"Error \".concat(refreshResult.status, \" no transaction returned from owner signs gatekeeper refresh request\"));\n              case 10:\n                return _context.abrupt(\"return\", refreshResult.transaction);\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n  var waitForUnexpiredGatewayToken = (0, react_1.useCallback)(function () {\n    return new Promise(function (resolve, reject) {\n      var isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n      logDebug('waitForUnexpiredGatewayToken: Waiting for unexpired token', {\n        gatewayToken: gatewayToken,\n        currentRefreshTimeoutId: setTimeoutForRefresh.current,\n        isExpired: isExpired\n      });\n      if (setTimeoutForRefresh.current) {\n        logDebug('waitForUnexpiredGatewayToken: Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n        clearTimeout(setTimeoutForRefresh.current);\n        setTimeoutForRefresh.current = null;\n      }\n      if (!isExpired) {\n        logDebug('waitForUnexpiredGatewayToken: Gateway token is unexpired', gatewayToken);\n        resolve();\n        return;\n      }\n      setTimeoutForRefresh.current = setTimeout(function () {\n        reject(new Error('Gateway token refresh has not been updated onChain'));\n      }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n      logDebug('waitForUnexpiredGatewayToken: Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n      if (ownerSigns) {\n        logDebug('waitForUnexpiredGatewayToken: emitting awaiting owner transaction');\n        // show the awaiting owner transaction UI if this is ownersigns\n        dispatch({\n          type: 'civicPass_awaiting_owner_transaction'\n        });\n      }\n    });\n  }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress]);\n  return {\n    checkForRefreshWithTimeout: checkForRefreshWithTimeout,\n    refreshToken: refreshToken,\n    waitForUnexpiredGatewayToken: waitForUnexpiredGatewayToken\n  };\n};\nexports.default = useRefresh;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","reducer","R","require","react_1","utils_1","logger_1","types_1","tokenUtils_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","refreshInProgress","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","refreshTokenState","RefreshTokenState","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","refreshTimeoutId","civicPass","responsePayload","renderIframe","iframeMinimized","CHECKING","WAIT_FOR_ON_CHAIN","useRefresh","dispatch","stage","gatekeeperClient","networkConfig","gatekeeperNetworkAddress","ownerSigns","walletAddress","logDebug","message","obj","default","debug","setTimeoutForRefresh","useRef","checkForRefreshWithTimeout","useCallback","expiryTime","tokenExpirationMarginSeconds","checkForExpirationIntervalMilliseconds","getTokenRefreshIntervalMilliseconds","timeoutId","setTimeout","shouldRefresh","isTokenRefreshRequired","expiring","margin","refreshToken","useWallet","proof","payload","wallet","refreshResult","status","Error","isNil","transaction","isEmpty","waitForUnexpiredGatewayToken","Promise","resolve","reject","isExpired","hasExpired","currentRefreshTimeoutId","current","clearTimeout","waitForTokenRefreshTimoutMilliseconds"],"sources":["/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@civic/common-gateway-react/dist/esm/useHooks/useRefresh.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst R = __importStar(require(\"ramda\"));\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });\n        }\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });\n        }\n        case 'refresh_clear_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });\n        case 'refresh_set_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });\n        case 'refresh_token_success':\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {\n    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const setTimeoutForRefresh = (0, react_1.useRef)(null);\n    /**\n     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n     * event, triggering the refreshFlow\n     */\n    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n        logDebug('Checking if refresh required', refreshTimeoutId);\n        dispatch({ type: 'refresh_status_check' });\n        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n            const { tokenExpirationMarginSeconds } = networkConfig;\n            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n            const timeoutId = setTimeout(() => {\n                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });\n                if (shouldRefresh) {\n                    logDebug('Refreshing Gateway Token');\n                    dispatch({ type: 'refresh_start' });\n                    dispatch({ type: 'civicPass_check_token_status' });\n                    return;\n                }\n                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });\n                dispatch({ type: 'refresh_complete' });\n            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n            logDebug('Setting token refresh timeout', {\n                expiring: gatewayToken.expiryTime,\n                checkForExpirationIntervalMilliseconds,\n                margin: tokenExpirationMarginSeconds,\n            });\n            dispatch({\n                type: 'refresh_set_timeout',\n                refreshTimeoutId: timeoutId,\n            });\n        }\n    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {\n        logDebug('Refresh token', { payload, proof });\n        dispatch({ type: 'refresh_with_powo_in_progress' });\n        const refreshResult = await gatekeeperClient().refreshToken({\n            wallet: useWallet,\n            payload,\n            proof,\n            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,\n        });\n        // fail for 4XX errors\n        if (refreshResult.status >= 400 && refreshResult.status < 500) {\n            throw new Error(`Error ${refreshResult.status} from refresh gatekeeper token request`);\n        }\n        // Fail if client sends and no transaction is returned\n        if (ownerSigns && (R.isNil(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction) || R.isEmpty(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction))) {\n            throw new Error(`Error ${refreshResult.status} no transaction returned from owner signs gatekeeper refresh request`);\n        }\n        return refreshResult.transaction;\n    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n        return new Promise((resolve, reject) => {\n            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n            logDebug('waitForUnexpiredGatewayToken: Waiting for unexpired token', {\n                gatewayToken,\n                currentRefreshTimeoutId: setTimeoutForRefresh.current,\n                isExpired,\n            });\n            if (setTimeoutForRefresh.current) {\n                logDebug('waitForUnexpiredGatewayToken: Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n                clearTimeout(setTimeoutForRefresh.current);\n                setTimeoutForRefresh.current = null;\n            }\n            if (!isExpired) {\n                logDebug('waitForUnexpiredGatewayToken: Gateway token is unexpired', gatewayToken);\n                resolve();\n                return;\n            }\n            setTimeoutForRefresh.current = setTimeout(() => {\n                reject(new Error('Gateway token refresh has not been updated onChain'));\n            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n            logDebug('waitForUnexpiredGatewayToken: Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n            if (ownerSigns) {\n                logDebug('waitForUnexpiredGatewayToken: emitting awaiting owner transaction');\n                // show the awaiting owner transaction UI if this is ownersigns\n                dispatch({ type: 'civicPass_awaiting_owner_transaction' });\n            }\n        });\n    }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress]);\n    return {\n        checkForRefreshWithTimeout,\n        refreshToken,\n        waitForUnexpiredGatewayToken,\n    };\n};\nexports.default = useRefresh;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}