{"ast":null,"code":"import _toConsumableArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport { IdlError } from \"../../error\";\nimport { toInstruction, validateAccounts, translateAddress } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nvar InstructionNamespaceFactory = /*#__PURE__*/function () {\n  function InstructionNamespaceFactory() {\n    _classCallCheck(this, InstructionNamespaceFactory);\n  }\n  _createClass(InstructionNamespaceFactory, null, [{\n    key: \"build\",\n    value: function build(idlIx, encodeFn, programId) {\n      if (idlIx.name === \"_inner\") {\n        throw new IdlError(\"the _inner name is reserved\");\n      }\n      var ix = function ix() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var _splitArgsAndCtx = splitArgsAndCtx(idlIx, [].concat(args)),\n          _splitArgsAndCtx2 = _slicedToArray(_splitArgsAndCtx, 2),\n          ixArgs = _splitArgsAndCtx2[0],\n          ctx = _splitArgsAndCtx2[1];\n        validateAccounts(idlIx.accounts, ctx.accounts);\n        validateInstruction.apply(void 0, [idlIx].concat(args));\n        var keys = ix.accounts(ctx.accounts);\n        if (ctx.remainingAccounts !== undefined) {\n          keys.push.apply(keys, _toConsumableArray(ctx.remainingAccounts));\n        }\n        if (ctx.__private && ctx.__private.logAccounts) {\n          console.log(\"Outgoing account metas:\", keys);\n        }\n        return new TransactionInstruction({\n          keys: keys,\n          programId: programId,\n          data: encodeFn(idlIx.name, toInstruction.apply(void 0, [idlIx].concat(_toConsumableArray(ixArgs))))\n        });\n      };\n      // Utility fn for ordering the accounts for this instruction.\n      ix[\"accounts\"] = function (accs) {\n        return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n      };\n      return ix;\n    }\n  }, {\n    key: \"accountsArray\",\n    value: function accountsArray(ctx, accounts) {\n      return accounts.map(function (acc) {\n        // Nested accounts.\n        // @ts-ignore\n        var nestedAccounts = acc.accounts;\n        if (nestedAccounts !== undefined) {\n          var rpcAccs = ctx[acc.name];\n          return InstructionNamespaceFactory.accountsArray(rpcAccs, nestedAccounts).flat();\n        } else {\n          var account = acc;\n          return {\n            pubkey: translateAddress(ctx[acc.name]),\n            isWritable: account.isMut,\n            isSigner: account.isSigner\n          };\n        }\n      }).flat();\n    }\n  }]);\n  return InstructionNamespaceFactory;\n}(); // Throws error if any argument required for the `ix` is not given.\nexport { InstructionNamespaceFactory as default };\nfunction validateInstruction(ix) {\n  // todo\n}","map":{"version":3,"sources":["../../../../src/program/namespace/instruction.ts"],"names":[],"mappings":";;;;AAAA,SAAoB,sBAAsB,QAAQ,iBAAiB;AAEnE,SAAS,QAAQ,QAAQ,aAAa;AACtC,SACE,aAAa,EACb,gBAAgB,EAChB,gBAAgB,QAEX,WAAW;AAClB,SAAmB,eAAe,QAAQ,YAAY;AAAC,IAElC,2BAA2B;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OACvC,eACL,KAAqB,EACrB,QAA6B,EAC7B,SAAoB,EAAA;MAEpB,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;QAC3B,MAAM,IAAI,QAAQ,CAAC,6BAA6B,CAAC;MAClD;MAED,IAAM,EAAE,GAAG,SAAL,EAAE,GAA8C;QAAA,kCAAvC,IAAW;UAAX,IAAW;QAAA;QACxB,uBAAsB,eAAe,CAAC,KAAK,YAAM,IAAI,EAAE;UAAA;UAAhD,MAAM;UAAE,GAAG;QAClB,gBAAgB,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAC,QAAQ,CAAC;QAC9C,mBAAmB,gBAAC,KAAK,SAAK,IAAI,EAAC;QAEnC,IAAM,IAAI,GAAG,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC;QAEtC,IAAI,GAAG,CAAC,iBAAiB,KAAK,SAAS,EAAE;UACvC,IAAI,CAAC,IAAI,OAAT,IAAI,qBAAS,GAAG,CAAC,iBAAiB,EAAC;QACpC;QAED,IAAI,GAAG,CAAC,SAAS,IAAI,GAAG,CAAC,SAAS,CAAC,WAAW,EAAE;UAC9C,OAAO,CAAC,GAAG,CAAC,yBAAyB,EAAE,IAAI,CAAC;QAC7C;QACD,OAAO,IAAI,sBAAsB,CAAC;UAChC,IAAI,EAAJ,IAAI;UACJ,SAAS,EAAT,SAAS;UACT,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,aAAa,gBAAC,KAAK,4BAAK,MAAM,GAAC;SAC3D,CAAC;MACJ,CAAC;MAED;MACA,EAAE,CAAC,UAAU,CAAC,GAAG,UAAC,IAAc,EAAI;QAClC,OAAO,2BAA2B,CAAC,aAAa,CAAC,IAAI,EAAE,KAAK,CAAC,QAAQ,CAAC;MACxE,CAAC;MAED,OAAO,EAAE;IACX;EAAC;IAAA;IAAA,OAEM,uBAAqB,GAAa,EAAE,QAA0B,EAAA;MACnE,OAAO,QAAQ,CACZ,GAAG,CAAC,UAAC,GAAmB,EAAI;QAC3B;QACA;QACA,IAAM,cAAc,GAAiC,GAAG,CAAC,QAAQ;QACjE,IAAI,cAAc,KAAK,SAAS,EAAE;UAChC,IAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,CAAa;UACzC,OAAO,2BAA2B,CAAC,aAAa,CAC9C,OAAO,EACP,cAAc,CACf,CAAC,IAAI,EAAE;SACT,MAAM;UACL,IAAM,OAAO,GAAe,GAAiB;UAC7C,OAAO;YACL,MAAM,EAAE,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAY,CAAC;YAClD,UAAU,EAAE,OAAO,CAAC,KAAK;YACzB,QAAQ,EAAE,OAAO,CAAC;WACnB;QACF;MACH,CAAC,CAAC,CACD,IAAI,EAAE;IACX;EAAC;EAAA;AAAA,KAgDH;AAAA,SA7GqB,2BAA2B;AA8GhD,SAAS,mBAAmB,CAAC,EAAkB,EAAgB;EAC7D;AAAA","sourceRoot":"","sourcesContent":["import { TransactionInstruction } from \"@solana/web3.js\";\nimport { IdlError } from \"../../error\";\nimport { toInstruction, validateAccounts, translateAddress, } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nexport default class InstructionNamespaceFactory {\n    static build(idlIx, encodeFn, programId) {\n        if (idlIx.name === \"_inner\") {\n            throw new IdlError(\"the _inner name is reserved\");\n        }\n        const ix = (...args) => {\n            const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            validateAccounts(idlIx.accounts, ctx.accounts);\n            validateInstruction(idlIx, ...args);\n            const keys = ix.accounts(ctx.accounts);\n            if (ctx.remainingAccounts !== undefined) {\n                keys.push(...ctx.remainingAccounts);\n            }\n            if (ctx.__private && ctx.__private.logAccounts) {\n                console.log(\"Outgoing account metas:\", keys);\n            }\n            return new TransactionInstruction({\n                keys,\n                programId,\n                data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),\n            });\n        };\n        // Utility fn for ordering the accounts for this instruction.\n        ix[\"accounts\"] = (accs) => {\n            return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n        };\n        return ix;\n    }\n    static accountsArray(ctx, accounts) {\n        return accounts\n            .map((acc) => {\n            // Nested accounts.\n            // @ts-ignore\n            const nestedAccounts = acc.accounts;\n            if (nestedAccounts !== undefined) {\n                const rpcAccs = ctx[acc.name];\n                return InstructionNamespaceFactory.accountsArray(rpcAccs, nestedAccounts).flat();\n            }\n            else {\n                const account = acc;\n                return {\n                    pubkey: translateAddress(ctx[acc.name]),\n                    isWritable: account.isMut,\n                    isSigner: account.isSigner,\n                };\n            }\n        })\n            .flat();\n    }\n}\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix, ...args) {\n    // todo\n}\n//# sourceMappingURL=instruction.js.map"]},"metadata":{},"sourceType":"module"}