{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.featureExists = exports.getFeatureAccountAddress = exports.gatekeeperExists = exports.getGatewayToken = exports.removeAccountChangeListener = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokens = exports.dataToGatewayToken = exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = exports.getGatekeeperAccountAddress = void 0;\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar constants_1 = require(\"./constants\");\nvar types_1 = require(\"../types\");\nvar GatewayTokenData_1 = require(\"./GatewayTokenData\");\nvar GatewayNetworkData_1 = require(\"./GatewayNetworkData\");\nvar bs58_1 = require(\"bs58\");\n/**\n * Derive the address of the gatekeeper PDA for this gatekeeper\n * @param authority The gatekeeper\n * @param network The network\n */\nvar getGatekeeperAccountAddress = function getGatekeeperAccountAddress(authority, network) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var publicKeyNonce;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return web3_js_1.PublicKey.findProgramAddress([authority.toBuffer(), network.toBuffer(), Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, \"utf8\")], constants_1.PROGRAM_ID);\n          case 2:\n            publicKeyNonce = _context.sent;\n            return _context.abrupt(\"return\", publicKeyNonce[0]);\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n};\nexports.getGatekeeperAccountAddress = getGatekeeperAccountAddress;\n/**\n * Derive the address of the gateway token PDA for this owner address and optional seed.\n * @param owner The owner of the gateway token\n * @param gatekeeperNetwork The network of the gateway token\n * @param seed An 8-byte seed array, used to add multiple tokens to the same owner. Must be unique to each token, if present\n */\nvar getGatewayTokenAddressForOwnerAndGatekeeperNetwork = function getGatewayTokenAddressForOwnerAndGatekeeperNetwork(owner, gatekeeperNetwork, seed) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var additionalSeed, seeds, publicKeyNonce;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            additionalSeed = seed ? Buffer.from(seed) : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n            if (!(additionalSeed.length != 8)) {\n              _context2.next = 3;\n              break;\n            }\n            throw new Error(\"Additional Seed has length \" + additionalSeed.length + \" instead of 8 when calling getGatewayTokenAddressForOwnerAndGatekeeperNetwork.\");\n          case 3:\n            seeds = [owner.toBuffer(), Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, \"utf8\"), additionalSeed, gatekeeperNetwork.toBuffer()];\n            _context2.next = 6;\n            return web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.PROGRAM_ID);\n          case 6:\n            publicKeyNonce = _context2.sent;\n            return _context2.abrupt(\"return\", publicKeyNonce[0]);\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n};\nexports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = getGatewayTokenAddressForOwnerAndGatekeeperNetwork;\n// Based on solana/integration-lib/src/state.rs\n// If the optional the parent-gateway-token field is populated, this value will be\n// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put\n// all optional values at the end of the struct to simplify account parsing a little\nvar GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2;\n// As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this\nvar GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;\nfunction fromGatewayTokenState(state) {\n  if (!!state.active) return types_1.State.ACTIVE;\n  if (!!state.revoked) return types_1.State.REVOKED;\n  if (!!state.frozen) return types_1.State.FROZEN;\n  throw new Error(\"Unrecognised state \" + JSON.stringify(state));\n}\nvar dataToGatewayToken = function dataToGatewayToken(data, publicKey) {\n  var _a;\n  return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());\n};\nexports.dataToGatewayToken = dataToGatewayToken;\n/**\n * Find all gateway tokens (optionally for a user) on a gatekeeper network, optionally filtering out revoked tokens.\n *\n * Warning - this uses the Solana getProgramAccounts RPC endpoint, which is inefficient and may be\n * blocked by some RPC services.\n *\n * @param connection A solana connection object\n * @param owner The token owner (optional)\n * @param gatekeeperNetwork The network to find a token for\n * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens\n * @param page If a large number of tokens has been issued, the request to the RPC endpoint may time out.\n * In this case, enable pagination by setting page variable\n * Pagination is not supported in the RPC API per-se, but this approximates it by\n * adding another filter on the first byte of the owner address.\n * Each page requests the accounts that match that byte.\n * @returns {Promise<GatewayToken[]>} All tokens for the owner\n */\nvar findGatewayTokens = function findGatewayTokens(connection, owner, gatekeeperNetwork) {\n  var includeRevoked = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var page = arguments.length > 4 ? arguments[4] : undefined;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var ownerFilter, gatekeeperNetworkFilter, pageFilter, filters, accountsResponse, toGatewayToken;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // if owner is specified, filter on the gateway token owner\n            ownerFilter = owner ? {\n              memcmp: {\n                offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n                bytes: owner.toBase58()\n              }\n            } : undefined; // filter on the gatekeeper network\n            gatekeeperNetworkFilter = {\n              memcmp: {\n                offset: GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,\n                bytes: gatekeeperNetwork.toBase58()\n              }\n            };\n            pageFilter = page !== undefined ? {\n              memcmp: {\n                offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n                bytes: (0, bs58_1.encode)([page])\n              }\n            } : undefined;\n            filters = [ownerFilter, gatekeeperNetworkFilter, pageFilter].filter(Boolean);\n            _context3.next = 6;\n            return connection.getProgramAccounts(constants_1.PROGRAM_ID, {\n              filters: filters\n            });\n          case 6:\n            accountsResponse = _context3.sent;\n            if (accountsResponse) {\n              _context3.next = 9;\n              break;\n            }\n            return _context3.abrupt(\"return\", []);\n          case 9:\n            toGatewayToken = function toGatewayToken(_ref) {\n              var pubkey = _ref.pubkey,\n                account = _ref.account;\n              return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);\n            };\n            return _context3.abrupt(\"return\", accountsResponse.map(toGatewayToken).filter(function (gatewayToken) {\n              return gatewayToken.state !== types_1.State.REVOKED || includeRevoked;\n            }));\n          case 11:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n};\nexports.findGatewayTokens = findGatewayTokens;\n/**\n * Get a gateway token for the owner and network, if it exists.\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner\n */\nvar findGatewayToken = function findGatewayToken(connection, owner, gatekeeperNetwork) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var gatewayTokenAddress, account;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(owner, gatekeeperNetwork);\n          case 2:\n            gatewayTokenAddress = _context4.sent;\n            _context4.next = 5;\n            return connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n          case 5:\n            account = _context4.sent;\n            if (account) {\n              _context4.next = 8;\n              break;\n            }\n            return _context4.abrupt(\"return\", null);\n          case 8:\n            return _context4.abrupt(\"return\", (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress));\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n};\nexports.findGatewayToken = findGatewayToken;\n/**\n * Register a callback to be called whenever a gateway token changes state\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n * @param callback The callback to register\n * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'\n * @return The subscription id\n */\nvar onGatewayTokenChange = function onGatewayTokenChange(connection, gatewayTokenAddress, callback) {\n  var commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.SOLANA_COMMITMENT;\n  var accountCallback = function accountCallback(accountInfo) {\n    var gatewayToken = (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);\n    callback(gatewayToken);\n  };\n  return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);\n};\nexports.onGatewayTokenChange = onGatewayTokenChange;\n/**\n * Stops listening to gateway state changes\n * @param connection A solana connection object\n * @param id The subscription id to deregister\n */\nvar removeAccountChangeListener = function removeAccountChangeListener(connection, id) {\n  return connection.removeAccountChangeListener(id);\n};\nexports.removeAccountChangeListener = removeAccountChangeListener;\n/**\n * Lookup the gateway token at a given address\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n */\nvar getGatewayToken = function getGatewayToken(connection, gatewayTokenAddress) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n    var account;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n          case 2:\n            account = _context5.sent;\n            if (account) {\n              _context5.next = 5;\n              break;\n            }\n            return _context5.abrupt(\"return\", null);\n          case 5:\n            return _context5.abrupt(\"return\", (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress));\n          case 6:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n};\nexports.getGatewayToken = getGatewayToken;\n/**\n * Returns whether or not a gatekeeper exists from a network and authority\n * @param connection A solana connection\n * @param gatekeeperAuthority The authority of the gatekeeper\n * @param gatekeeperNetwork The network of the gatekeeper\n */\nvar gatekeeperExists = function gatekeeperExists(connection, gatekeeperAuthority, gatekeeperNetwork) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n    var gatekeeperAccount, account;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return (0, exports.getGatekeeperAccountAddress)(gatekeeperAuthority, gatekeeperNetwork);\n          case 2:\n            gatekeeperAccount = _context6.sent;\n            _context6.next = 5;\n            return connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);\n          case 5:\n            account = _context6.sent;\n            return _context6.abrupt(\"return\", account != null && constants_1.PROGRAM_ID.equals(account.owner));\n          case 7:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n};\nexports.gatekeeperExists = gatekeeperExists;\n/**\n * Derive the address of the feature PDA\n * @param featureName The name of the feature to set.\n * @param network The network\n */\nvar getFeatureAccountAddress = function getFeatureAccountAddress(feature, network) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n    var featureName, publicKeyNonce;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            featureName = (0, GatewayNetworkData_1.mapEnumToFeatureName)(feature.enum);\n            _context7.next = 3;\n            return web3_js_1.PublicKey.findProgramAddress([network.toBytes(), Buffer.from(featureName, \"utf8\")], constants_1.PROGRAM_ID);\n          case 3:\n            publicKeyNonce = _context7.sent;\n            return _context7.abrupt(\"return\", publicKeyNonce[0]);\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n};\nexports.getFeatureAccountAddress = getFeatureAccountAddress;\n/**\n * Return true if an address feature exists.\n * @param connection\n * @param feature The feature to check\n * @param network The gatekeeper network\n */\nvar featureExists = function featureExists(connection, feature, network) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n    var featureAccountAddress, account;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return (0, exports.getFeatureAccountAddress)(feature, network);\n          case 2:\n            featureAccountAddress = _context8.sent;\n            _context8.next = 5;\n            return connection.getAccountInfo(featureAccountAddress, constants_1.SOLANA_COMMITMENT);\n          case 5:\n            account = _context8.sent;\n            return _context8.abrupt(\"return\", account != null && constants_1.PROGRAM_ID.equals(account.owner));\n          case 7:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n};\nexports.featureExists = featureExists;","map":{"version":3,"sources":["../../src/lib/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.featureExists = exports.getFeatureAccountAddress = exports.gatekeeperExists = exports.getGatewayToken = exports.removeAccountChangeListener = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokens = exports.dataToGatewayToken = exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = exports.getGatekeeperAccountAddress = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst constants_1 = require(\"./constants\");\nconst types_1 = require(\"../types\");\nconst GatewayTokenData_1 = require(\"./GatewayTokenData\");\nconst GatewayNetworkData_1 = require(\"./GatewayNetworkData\");\nconst bs58_1 = require(\"bs58\");\n/**\n * Derive the address of the gatekeeper PDA for this gatekeeper\n * @param authority The gatekeeper\n * @param network The network\n */\nconst getGatekeeperAccountAddress = (authority, network) => __awaiter(void 0, void 0, void 0, function* () {\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([\n        authority.toBuffer(),\n        network.toBuffer(),\n        Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, \"utf8\"),\n    ], constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getGatekeeperAccountAddress = getGatekeeperAccountAddress;\n/**\n * Derive the address of the gateway token PDA for this owner address and optional seed.\n * @param owner The owner of the gateway token\n * @param gatekeeperNetwork The network of the gateway token\n * @param seed An 8-byte seed array, used to add multiple tokens to the same owner. Must be unique to each token, if present\n */\nconst getGatewayTokenAddressForOwnerAndGatekeeperNetwork = (owner, gatekeeperNetwork, seed) => __awaiter(void 0, void 0, void 0, function* () {\n    const additionalSeed = seed\n        ? Buffer.from(seed)\n        : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n    if (additionalSeed.length != 8) {\n        throw new Error(\"Additional Seed has length \" +\n            additionalSeed.length +\n            \" instead of 8 when calling getGatewayTokenAddressForOwnerAndGatekeeperNetwork.\");\n    }\n    const seeds = [\n        owner.toBuffer(),\n        Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, \"utf8\"),\n        additionalSeed,\n        gatekeeperNetwork.toBuffer(),\n    ];\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = getGatewayTokenAddressForOwnerAndGatekeeperNetwork;\n// Based on solana/integration-lib/src/state.rs\n// If the optional the parent-gateway-token field is populated, this value will be\n// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put\n// all optional values at the end of the struct to simplify account parsing a little\nconst GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2;\n// As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this\nconst GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;\nfunction fromGatewayTokenState(state) {\n    if (!!state.active)\n        return types_1.State.ACTIVE;\n    if (!!state.revoked)\n        return types_1.State.REVOKED;\n    if (!!state.frozen)\n        return types_1.State.FROZEN;\n    throw new Error(\"Unrecognised state \" + JSON.stringify(state));\n}\nconst dataToGatewayToken = (data, publicKey) => {\n    var _a;\n    return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());\n};\nexports.dataToGatewayToken = dataToGatewayToken;\n/**\n * Find all gateway tokens (optionally for a user) on a gatekeeper network, optionally filtering out revoked tokens.\n *\n * Warning - this uses the Solana getProgramAccounts RPC endpoint, which is inefficient and may be\n * blocked by some RPC services.\n *\n * @param connection A solana connection object\n * @param owner The token owner (optional)\n * @param gatekeeperNetwork The network to find a token for\n * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens\n * @param page If a large number of tokens has been issued, the request to the RPC endpoint may time out.\n * In this case, enable pagination by setting page variable\n * Pagination is not supported in the RPC API per-se, but this approximates it by\n * adding another filter on the first byte of the owner address.\n * Each page requests the accounts that match that byte.\n * @returns {Promise<GatewayToken[]>} All tokens for the owner\n */\nconst findGatewayTokens = (connection, owner, gatekeeperNetwork, includeRevoked = false, page) => __awaiter(void 0, void 0, void 0, function* () {\n    // if owner is specified, filter on the gateway token owner\n    const ownerFilter = owner\n        ? {\n            memcmp: {\n                offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n                bytes: owner.toBase58(),\n            },\n        }\n        : undefined;\n    // filter on the gatekeeper network\n    const gatekeeperNetworkFilter = {\n        memcmp: {\n            offset: GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,\n            bytes: gatekeeperNetwork.toBase58(),\n        },\n    };\n    const pageFilter = page !== undefined\n        ? {\n            memcmp: {\n                offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n                bytes: (0, bs58_1.encode)([page]),\n            },\n        }\n        : undefined;\n    const filters = [ownerFilter, gatekeeperNetworkFilter, pageFilter].filter(Boolean);\n    const accountsResponse = yield connection.getProgramAccounts(constants_1.PROGRAM_ID, {\n        filters,\n    });\n    if (!accountsResponse)\n        return [];\n    const toGatewayToken = ({ pubkey, account, }) => (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);\n    return accountsResponse\n        .map(toGatewayToken)\n        .filter((gatewayToken) => gatewayToken.state !== types_1.State.REVOKED || includeRevoked);\n});\nexports.findGatewayTokens = findGatewayTokens;\n/**\n * Get a gateway token for the owner and network, if it exists.\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner\n */\nconst findGatewayToken = (connection, owner, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n    const gatewayTokenAddress = yield (0, exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(owner, gatekeeperNetwork);\n    const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n    if (!account)\n        return null;\n    return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\nexports.findGatewayToken = findGatewayToken;\n/**\n * Register a callback to be called whenever a gateway token changes state\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n * @param callback The callback to register\n * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'\n * @return The subscription id\n */\nconst onGatewayTokenChange = (connection, gatewayTokenAddress, callback, commitment = constants_1.SOLANA_COMMITMENT) => {\n    const accountCallback = (accountInfo) => {\n        const gatewayToken = (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);\n        callback(gatewayToken);\n    };\n    return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);\n};\nexports.onGatewayTokenChange = onGatewayTokenChange;\n/**\n * Stops listening to gateway state changes\n * @param connection A solana connection object\n * @param id The subscription id to deregister\n */\nconst removeAccountChangeListener = (connection, id) => connection.removeAccountChangeListener(id);\nexports.removeAccountChangeListener = removeAccountChangeListener;\n/**\n * Lookup the gateway token at a given address\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n */\nconst getGatewayToken = (connection, gatewayTokenAddress) => __awaiter(void 0, void 0, void 0, function* () {\n    const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n    if (!account)\n        return null;\n    return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\nexports.getGatewayToken = getGatewayToken;\n/**\n * Returns whether or not a gatekeeper exists from a network and authority\n * @param connection A solana connection\n * @param gatekeeperAuthority The authority of the gatekeeper\n * @param gatekeeperNetwork The network of the gatekeeper\n */\nconst gatekeeperExists = (connection, gatekeeperAuthority, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n    const gatekeeperAccount = yield (0, exports.getGatekeeperAccountAddress)(gatekeeperAuthority, gatekeeperNetwork);\n    const account = yield connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);\n    return account != null && constants_1.PROGRAM_ID.equals(account.owner);\n});\nexports.gatekeeperExists = gatekeeperExists;\n/**\n * Derive the address of the feature PDA\n * @param featureName The name of the feature to set.\n * @param network The network\n */\nconst getFeatureAccountAddress = (feature, network) => __awaiter(void 0, void 0, void 0, function* () {\n    const featureName = (0, GatewayNetworkData_1.mapEnumToFeatureName)(feature.enum);\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([network.toBytes(), Buffer.from(featureName, \"utf8\")], constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getFeatureAccountAddress = getFeatureAccountAddress;\n/**\n * Return true if an address feature exists.\n * @param connection\n * @param feature The feature to check\n * @param network The gatekeeper network\n */\nconst featureExists = (connection, feature, network) => __awaiter(void 0, void 0, void 0, function* () {\n    const featureAccountAddress = yield (0, exports.getFeatureAccountAddress)(feature, network);\n    const account = yield connection.getAccountInfo(featureAccountAddress, constants_1.SOLANA_COMMITMENT);\n    return account != null && constants_1.PROGRAM_ID.equals(account.owner);\n});\nexports.featureExists = featureExists;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}