{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Connection, Keypair, sendAndConfirmRawTransaction } from \"@solana/web3.js\";\nimport { isBrowser } from \"./utils/common\";\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nvar Provider = /*#__PURE__*/function () {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  function Provider(connection, wallet, opts) {\n    _classCallCheck(this, Provider);\n    this.connection = connection;\n    this.wallet = wallet;\n    this.opts = opts;\n  }\n  _createClass(Provider, [{\n    key: \"send\",\n    value:\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx, signers, opts) {\n        var rawTx, txId;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (signers === undefined) {\n                  signers = [];\n                }\n                if (opts === undefined) {\n                  opts = this.opts;\n                }\n                tx.feePayer = this.wallet.publicKey;\n                _context.next = 5;\n                return this.connection.getRecentBlockhash(opts.preflightCommitment);\n              case 5:\n                tx.recentBlockhash = _context.sent.blockhash;\n                _context.next = 8;\n                return this.wallet.signTransaction(tx);\n              case 8:\n                signers.filter(function (s) {\n                  return s !== undefined;\n                }).forEach(function (kp) {\n                  tx.partialSign(kp);\n                });\n                rawTx = tx.serialize();\n                _context.next = 12;\n                return sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n              case 12:\n                txId = _context.sent;\n                return _context.abrupt(\"return\", txId);\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function send(_x, _x2, _x3) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }()\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n  }, {\n    key: \"sendAll\",\n    value: function () {\n      var _sendAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(reqs, opts) {\n        var _this = this;\n        var blockhash, txs, signedTxs, sigs, k, tx, rawTx;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (opts === undefined) {\n                  opts = this.opts;\n                }\n                _context2.next = 3;\n                return this.connection.getRecentBlockhash(opts.preflightCommitment);\n              case 3:\n                blockhash = _context2.sent;\n                txs = reqs.map(function (r) {\n                  var tx = r.tx;\n                  var signers = r.signers;\n                  if (signers === undefined) {\n                    signers = [];\n                  }\n                  tx.feePayer = _this.wallet.publicKey;\n                  tx.recentBlockhash = blockhash.blockhash;\n                  signers.filter(function (s) {\n                    return s !== undefined;\n                  }).forEach(function (kp) {\n                    tx.partialSign(kp);\n                  });\n                  return tx;\n                });\n                _context2.next = 7;\n                return this.wallet.signAllTransactions(txs);\n              case 7:\n                signedTxs = _context2.sent;\n                sigs = [];\n                k = 0;\n              case 10:\n                if (!(k < txs.length)) {\n                  _context2.next = 21;\n                  break;\n                }\n                tx = signedTxs[k];\n                rawTx = tx.serialize();\n                _context2.t0 = sigs;\n                _context2.next = 16;\n                return sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n              case 16:\n                _context2.t1 = _context2.sent;\n                _context2.t0.push.call(_context2.t0, _context2.t1);\n              case 18:\n                k += 1;\n                _context2.next = 10;\n                break;\n              case 21:\n                return _context2.abrupt(\"return\", sigs);\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function sendAll(_x4, _x5) {\n        return _sendAll.apply(this, arguments);\n      }\n      return sendAll;\n    }()\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n  }, {\n    key: \"simulate\",\n    value: function () {\n      var _simulate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx, signers, opts) {\n        var _a, _b;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (signers === undefined) {\n                  signers = [];\n                }\n                if (opts === undefined) {\n                  opts = this.opts;\n                }\n                tx.feePayer = this.wallet.publicKey;\n                _context3.next = 5;\n                return this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment);\n              case 5:\n                tx.recentBlockhash = _context3.sent.blockhash;\n                _context3.next = 8;\n                return this.wallet.signTransaction(tx);\n              case 8:\n                signers.filter(function (s) {\n                  return s !== undefined;\n                }).forEach(function (kp) {\n                  tx.partialSign(kp);\n                });\n                _context3.next = 11;\n                return simulateTransaction(this.connection, tx, (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment);\n              case 11:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function simulate(_x6, _x7, _x8) {\n        return _simulate.apply(this, arguments);\n      }\n      return simulate;\n    }()\n  }], [{\n    key: \"defaultOptions\",\n    value: function defaultOptions() {\n      return {\n        preflightCommitment: \"recent\",\n        commitment: \"recent\"\n      };\n    }\n    /**\n     * Returns a `Provider` with a wallet read from the local filesystem.\n     *\n     * @param url  The network cluster url.\n     * @param opts The default transaction confirmation options.\n     *\n     * (This api is for Node only.)\n     */\n  }, {\n    key: \"local\",\n    value: function local(url, opts) {\n      opts = opts !== null && opts !== void 0 ? opts : Provider.defaultOptions();\n      var connection = new Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\n      var wallet = NodeWallet.local();\n      return new Provider(connection, wallet, opts);\n    }\n    /**\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n     * variable\n     *\n     * (This api is for Node only.)\n     */\n  }, {\n    key: \"env\",\n    value: function env() {\n      if (isBrowser) return;\n      var process = require(\"process\");\n      var url = process.env.ANCHOR_PROVIDER_URL;\n      if (url === undefined) {\n        throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n      }\n      var options = Provider.defaultOptions();\n      var connection = new Connection(url, options.commitment);\n      var wallet = NodeWallet.local();\n      return new Provider(connection, wallet, options);\n    }\n  }]);\n  return Provider;\n}();\n/**\n * Node only wallet.\n */\nexport { Provider as default };\nexport var NodeWallet = /*#__PURE__*/function () {\n  function NodeWallet(payer) {\n    _classCallCheck(this, NodeWallet);\n    this.payer = payer;\n  }\n  _createClass(NodeWallet, [{\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tx) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                tx.partialSign(this.payer);\n                return _context4.abrupt(\"return\", tx);\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function signTransaction(_x9) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signAllTransactions\",\n    value: function () {\n      var _signAllTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(txs) {\n        var _this2 = this;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", txs.map(function (t) {\n                  t.partialSign(_this2.payer);\n                  return t;\n                }));\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      function signAllTransactions(_x10) {\n        return _signAllTransactions.apply(this, arguments);\n      }\n      return signAllTransactions;\n    }()\n  }, {\n    key: \"publicKey\",\n    get: function get() {\n      return this.payer.publicKey;\n    }\n  }], [{\n    key: \"local\",\n    value: function local() {\n      var payer = Keypair.fromSecretKey(Buffer.from(JSON.parse(require(\"fs\").readFileSync(require(\"os\").homedir() + \"/.config/solana/id.json\", {\n        encoding: \"utf-8\"\n      }))));\n      return new NodeWallet(payer);\n    }\n  }]);\n  return NodeWallet;\n}();\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\nfunction simulateTransaction(_x11, _x12, _x13) {\n  return _simulateTransaction.apply(this, arguments);\n}\n/**\n * Sets the default provider on the client.\n */\nfunction _simulateTransaction() {\n  _simulateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(connection, transaction, commitment) {\n    var signData, wireTransaction, encodedTransaction, config, args, res;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return connection._recentBlockhash(\n            // @ts-ignore\n            connection._disableBlockhashCaching);\n          case 2:\n            transaction.recentBlockhash = _context6.sent;\n            signData = transaction.serializeMessage(); // @ts-ignore\n            wireTransaction = transaction._serialize(signData);\n            encodedTransaction = wireTransaction.toString(\"base64\");\n            config = {\n              encoding: \"base64\",\n              commitment: commitment\n            };\n            args = [encodedTransaction, config]; // @ts-ignore\n            _context6.next = 10;\n            return connection._rpcRequest(\"simulateTransaction\", args);\n          case 10:\n            res = _context6.sent;\n            if (!res.error) {\n              _context6.next = 13;\n              break;\n            }\n            throw new Error(\"failed to simulate transaction: \" + res.error.message);\n          case 13:\n            return _context6.abrupt(\"return\", res.result);\n          case 14:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _simulateTransaction.apply(this, arguments);\n}\nexport function setProvider(provider) {\n  _provider = provider;\n}\n/**\n * Returns the default provider being used by the client.\n */\nexport function getProvider() {\n  if (_provider === null) {\n    return Provider.local();\n  }\n  return _provider;\n}\n// Global provider used as the default when a provider is not given.\nvar _provider = null;","map":{"version":3,"sources":["../../src/provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Connection, Keypair, sendAndConfirmRawTransaction, } from \"@solana/web3.js\";\nimport { isBrowser } from \"./utils/common\";\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nexport default class Provider {\n    /**\n     * @param connection The cluster connection where the program is deployed.\n     * @param wallet     The wallet used to pay for and sign all transactions.\n     * @param opts       Transaction confirmation options to use by default.\n     */\n    constructor(connection, wallet, opts) {\n        this.connection = connection;\n        this.wallet = wallet;\n        this.opts = opts;\n    }\n    static defaultOptions() {\n        return {\n            preflightCommitment: \"recent\",\n            commitment: \"recent\",\n        };\n    }\n    /**\n     * Returns a `Provider` with a wallet read from the local filesystem.\n     *\n     * @param url  The network cluster url.\n     * @param opts The default transaction confirmation options.\n     *\n     * (This api is for Node only.)\n     */\n    static local(url, opts) {\n        opts = opts !== null && opts !== void 0 ? opts : Provider.defaultOptions();\n        const connection = new Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\n        const wallet = NodeWallet.local();\n        return new Provider(connection, wallet, opts);\n    }\n    /**\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n     * variable\n     *\n     * (This api is for Node only.)\n     */\n    static env() {\n        if (isBrowser)\n            return;\n        const process = require(\"process\");\n        const url = process.env.ANCHOR_PROVIDER_URL;\n        if (url === undefined) {\n            throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n        }\n        const options = Provider.defaultOptions();\n        const connection = new Connection(url, options.commitment);\n        const wallet = NodeWallet.local();\n        return new Provider(connection, wallet, options);\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    async send(tx, signers, opts) {\n        if (signers === undefined) {\n            signers = [];\n        }\n        if (opts === undefined) {\n            opts = this.opts;\n        }\n        tx.feePayer = this.wallet.publicKey;\n        tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;\n        await this.wallet.signTransaction(tx);\n        signers\n            .filter((s) => s !== undefined)\n            .forEach((kp) => {\n            tx.partialSign(kp);\n        });\n        const rawTx = tx.serialize();\n        const txId = await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n        return txId;\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n    async sendAll(reqs, opts) {\n        if (opts === undefined) {\n            opts = this.opts;\n        }\n        const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);\n        let txs = reqs.map((r) => {\n            let tx = r.tx;\n            let signers = r.signers;\n            if (signers === undefined) {\n                signers = [];\n            }\n            tx.feePayer = this.wallet.publicKey;\n            tx.recentBlockhash = blockhash.blockhash;\n            signers\n                .filter((s) => s !== undefined)\n                .forEach((kp) => {\n                tx.partialSign(kp);\n            });\n            return tx;\n        });\n        const signedTxs = await this.wallet.signAllTransactions(txs);\n        const sigs = [];\n        for (let k = 0; k < txs.length; k += 1) {\n            const tx = signedTxs[k];\n            const rawTx = tx.serialize();\n            sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\n        }\n        return sigs;\n    }\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    async simulate(tx, signers, opts) {\n        var _a, _b;\n        if (signers === undefined) {\n            signers = [];\n        }\n        if (opts === undefined) {\n            opts = this.opts;\n        }\n        tx.feePayer = this.wallet.publicKey;\n        tx.recentBlockhash = (await this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment)).blockhash;\n        await this.wallet.signTransaction(tx);\n        signers\n            .filter((s) => s !== undefined)\n            .forEach((kp) => {\n            tx.partialSign(kp);\n        });\n        return await simulateTransaction(this.connection, tx, (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment);\n    }\n}\n/**\n * Node only wallet.\n */\nexport class NodeWallet {\n    constructor(payer) {\n        this.payer = payer;\n    }\n    static local() {\n        const payer = Keypair.fromSecretKey(Buffer.from(JSON.parse(require(\"fs\").readFileSync(require(\"os\").homedir() + \"/.config/solana/id.json\", {\n            encoding: \"utf-8\",\n        }))));\n        return new NodeWallet(payer);\n    }\n    async signTransaction(tx) {\n        tx.partialSign(this.payer);\n        return tx;\n    }\n    async signAllTransactions(txs) {\n        return txs.map((t) => {\n            t.partialSign(this.payer);\n            return t;\n        });\n    }\n    get publicKey() {\n        return this.payer.publicKey;\n    }\n}\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\nasync function simulateTransaction(connection, transaction, commitment) {\n    // @ts-ignore\n    transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching);\n    const signData = transaction.serializeMessage();\n    // @ts-ignore\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString(\"base64\");\n    const config = { encoding: \"base64\", commitment };\n    const args = [encodedTransaction, config];\n    // @ts-ignore\n    const res = await connection._rpcRequest(\"simulateTransaction\", args);\n    if (res.error) {\n        throw new Error(\"failed to simulate transaction: \" + res.error.message);\n    }\n    return res.result;\n}\n/**\n * Sets the default provider on the client.\n */\nexport function setProvider(provider) {\n    _provider = provider;\n}\n/**\n * Returns the default provider being used by the client.\n */\nexport function getProvider() {\n    if (_provider === null) {\n        return Provider.local();\n    }\n    return _provider;\n}\n// Global provider used as the default when a provider is not given.\nlet _provider = null;\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}