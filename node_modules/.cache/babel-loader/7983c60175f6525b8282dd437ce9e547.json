{"ast":null,"code":"import useCustomEffect from './useCustomEffect';\nimport { dequal } from 'dequal';\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\nimport { useState } from 'react';\nfunction isDepsEqual(_ref, _ref2) {\n  var nextElement = _ref[0],\n    nextConfig = _ref[1];\n  var prevElement = _ref2[0],\n    prevConfig = _ref2[1];\n  return nextElement === prevElement && dequal(nextConfig, prevConfig);\n}\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\nfunction useMutationObserver(element, config, callback) {\n  var _useState = useState(null),\n    records = _useState[0],\n    setRecords = _useState[1];\n  var handler = useEventCallback(callback || setRecords);\n  useCustomEffect(function () {\n    if (!element) return; // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n\n    var observer = new MutationObserver(handler);\n    observer.observe(element, config);\n    return function () {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n  return callback ? void 0 : records || [];\n}\nexport default useMutationObserver;","map":{"version":3,"names":["useCustomEffect","dequal","useImmediateUpdateEffect","useEventCallback","useState","isDepsEqual","_ref","_ref2","nextElement","nextConfig","prevElement","prevConfig","useMutationObserver","element","config","callback","_useState","records","setRecords","handler","observer","MutationObserver","observe","disconnect","isEqual","effectHook"],"sources":["/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@restart/hooks/esm/useMutationObserver.js"],"sourcesContent":["import useCustomEffect from './useCustomEffect';\nimport { dequal } from 'dequal';\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\nimport { useState } from 'react';\n\nfunction isDepsEqual(_ref, _ref2) {\n  var nextElement = _ref[0],\n      nextConfig = _ref[1];\n  var prevElement = _ref2[0],\n      prevConfig = _ref2[1];\n  return nextElement === prevElement && dequal(nextConfig, prevConfig);\n}\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\n\nfunction useMutationObserver(element, config, callback) {\n  var _useState = useState(null),\n      records = _useState[0],\n      setRecords = _useState[1];\n\n  var handler = useEventCallback(callback || setRecords);\n  useCustomEffect(function () {\n    if (!element) return; // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n\n    var observer = new MutationObserver(handler);\n    observer.observe(element, config);\n    return function () {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n  return callback ? void 0 : records || [];\n}\n\nexport default useMutationObserver;"],"mappings":"AAAA,OAAOA,eAAe,MAAM,mBAAmB;AAC/C,SAASC,MAAM,QAAQ,QAAQ;AAC/B,OAAOC,wBAAwB,MAAM,4BAA4B;AACjE,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,SAASC,QAAQ,QAAQ,OAAO;AAEhC,SAASC,WAAW,CAACC,IAAI,EAAEC,KAAK,EAAE;EAChC,IAAIC,WAAW,GAAGF,IAAI,CAAC,CAAC,CAAC;IACrBG,UAAU,GAAGH,IAAI,CAAC,CAAC,CAAC;EACxB,IAAII,WAAW,GAAGH,KAAK,CAAC,CAAC,CAAC;IACtBI,UAAU,GAAGJ,KAAK,CAAC,CAAC,CAAC;EACzB,OAAOC,WAAW,KAAKE,WAAW,IAAIT,MAAM,CAACQ,UAAU,EAAEE,UAAU,CAAC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASC,mBAAmB,CAACC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACtD,IAAIC,SAAS,GAAGZ,QAAQ,CAAC,IAAI,CAAC;IAC1Ba,OAAO,GAAGD,SAAS,CAAC,CAAC,CAAC;IACtBE,UAAU,GAAGF,SAAS,CAAC,CAAC,CAAC;EAE7B,IAAIG,OAAO,GAAGhB,gBAAgB,CAACY,QAAQ,IAAIG,UAAU,CAAC;EACtDlB,eAAe,CAAC,YAAY;IAC1B,IAAI,CAACa,OAAO,EAAE,OAAO,CAAC;IACtB;IACA;IACA;;IAEA,IAAIO,QAAQ,GAAG,IAAIC,gBAAgB,CAACF,OAAO,CAAC;IAC5CC,QAAQ,CAACE,OAAO,CAACT,OAAO,EAAEC,MAAM,CAAC;IACjC,OAAO,YAAY;MACjBM,QAAQ,CAACG,UAAU,EAAE;IACvB,CAAC;EACH,CAAC,EAAE,CAACV,OAAO,EAAEC,MAAM,CAAC,EAAE;IACpBU,OAAO,EAAEnB,WAAW;IACpB;IACA;IACAoB,UAAU,EAAEvB;EACd,CAAC,CAAC;EACF,OAAOa,QAAQ,GAAG,KAAK,CAAC,GAAGE,OAAO,IAAI,EAAE;AAC1C;AAEA,eAAeL,mBAAmB"},"metadata":{},"sourceType":"module"}