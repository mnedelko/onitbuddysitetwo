{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountDiscriminator, accountSize } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nvar AccountFactory = /*#__PURE__*/function () {\n  function AccountFactory() {\n    _classCallCheck(this, AccountFactory);\n  }\n  _createClass(AccountFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      var accountFns = {};\n      idl.accounts.forEach(function (idlAccount) {\n        var name = camelCase(idlAccount.name);\n        accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n      });\n      return accountFns;\n    }\n  }]);\n  return AccountFactory;\n}();\nexport { AccountFactory as default };\nexport var AccountClient = /*#__PURE__*/function () {\n  function AccountClient(idl, idlAccount, programId, provider, coder) {\n    _classCallCheck(this, AccountClient);\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n    this._size = ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount);\n  }\n  /**\n   * Returns the number of bytes in this account.\n   */\n  _createClass(AccountClient, [{\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n  }, {\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(address) {\n        var accountInfo, discriminator;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._provider.connection.getAccountInfo(translateAddress(address));\n              case 2:\n                accountInfo = _context.sent;\n                if (!(accountInfo === null)) {\n                  _context.next = 5;\n                  break;\n                }\n                throw new Error(\"Account does not exist \".concat(address.toString()));\n              case 5:\n                _context.next = 7;\n                return accountDiscriminator(this._idlAccount.name);\n              case 7:\n                discriminator = _context.sent;\n                if (!discriminator.compare(accountInfo.data.slice(0, 8))) {\n                  _context.next = 10;\n                  break;\n                }\n                throw new Error(\"Invalid account discriminator\");\n              case 10:\n                return _context.abrupt(\"return\", this._coder.accounts.decode(this._idlAccount.name, accountInfo.data));\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function fetch(_x) {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n    /**\n     * Returns all instances of this account type for the program.\n     */\n  }, {\n    key: \"all\",\n    value: function () {\n      var _all = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(filter) {\n        var _this = this;\n        var bytes, resp;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return accountDiscriminator(this._idlAccount.name);\n              case 2:\n                bytes = _context2.sent;\n                if (filter !== undefined) {\n                  bytes = Buffer.concat([bytes, filter]);\n                }\n                _context2.next = 6;\n                return this._provider.connection.getProgramAccounts(this._programId, {\n                  commitment: this._provider.connection.commitment,\n                  filters: [{\n                    memcmp: {\n                      offset: 0,\n                      bytes: bs58.encode(bytes)\n                    }\n                  }]\n                });\n              case 6:\n                resp = _context2.sent;\n                return _context2.abrupt(\"return\", resp.map(function (_ref) {\n                  var pubkey = _ref.pubkey,\n                    account = _ref.account;\n                  return {\n                    publicKey: pubkey,\n                    account: _this._coder.accounts.decode(_this._idlAccount.name, account.data)\n                  };\n                }));\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function all(_x2) {\n        return _all.apply(this, arguments);\n      }\n      return all;\n    }()\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(address, commitment) {\n      var _this2 = this;\n      if (subscriptions.get(address.toString())) {\n        return subscriptions.get(address.toString()).ee;\n      }\n      var ee = new EventEmitter();\n      address = translateAddress(address);\n      var listener = this._provider.connection.onAccountChange(address, function (acc) {\n        var account = _this2._coder.accounts.decode(_this2._idlAccount.name, acc.data);\n        ee.emit(\"change\", account);\n      }, commitment);\n      subscriptions.set(address.toString(), {\n        ee: ee,\n        listener: listener\n      });\n      return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(address) {\n      var sub = subscriptions.get(address.toString());\n      if (!sub) {\n        console.warn(\"Address is not subscribed\");\n        return;\n      }\n      if (subscriptions) {\n        this._provider.connection.removeAccountChangeListener(sub.listener).then(function () {\n          subscriptions.delete(address.toString());\n        }).catch(console.error);\n      }\n    }\n    /**\n     * Returns an instruction for creating this account.\n     */\n  }, {\n    key: \"createInstruction\",\n    value: function () {\n      var _createInstruction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(signer, sizeOverride) {\n        var size;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                size = this.size;\n                _context3.t0 = SystemProgram;\n                _context3.t1 = this._provider.wallet.publicKey;\n                _context3.t2 = signer.publicKey;\n                _context3.t3 = sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size;\n                _context3.next = 7;\n                return this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size);\n              case 7:\n                _context3.t4 = _context3.sent;\n                _context3.t5 = this._programId;\n                _context3.t6 = {\n                  fromPubkey: _context3.t1,\n                  newAccountPubkey: _context3.t2,\n                  space: _context3.t3,\n                  lamports: _context3.t4,\n                  programId: _context3.t5\n                };\n                return _context3.abrupt(\"return\", _context3.t0.createAccount.call(_context3.t0, _context3.t6));\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function createInstruction(_x3, _x4) {\n        return _createInstruction.apply(this, arguments);\n      }\n      return createInstruction;\n    }()\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n  }, {\n    key: \"associated\",\n    value: function () {\n      var _associated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var addr,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.associatedAddress.apply(this, _args4);\n              case 2:\n                addr = _context4.sent;\n                _context4.next = 5;\n                return this.fetch(addr);\n              case 5:\n                return _context4.abrupt(\"return\", _context4.sent);\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function associated() {\n        return _associated.apply(this, arguments);\n      }\n      return associated;\n    }()\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated address. Args are keys to associate.\n     * Order matters.\n     */\n  }, {\n    key: \"associatedAddress\",\n    value: function () {\n      var _associatedAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _len,\n          args,\n          _key,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                for (_len = _args5.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = _args5[_key];\n                }\n                _context5.next = 3;\n                return pubkeyUtil.associated.apply(pubkeyUtil, [this._programId].concat(args));\n              case 3:\n                return _context5.abrupt(\"return\", _context5.sent);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function associatedAddress() {\n        return _associatedAddress.apply(this, arguments);\n      }\n      return associatedAddress;\n    }()\n  }]);\n  return AccountClient;\n}();\n// Tracks all subscriptions.\nvar subscriptions = new Map();","map":{"version":3,"sources":["../../../../src/program/namespace/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram, } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountDiscriminator, accountSize, } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nexport default class AccountFactory {\n    static build(idl, coder, programId, provider) {\n        const accountFns = {};\n        idl.accounts.forEach((idlAccount) => {\n            const name = camelCase(idlAccount.name);\n            accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n        });\n        return accountFns;\n    }\n}\nexport class AccountClient {\n    constructor(idl, idlAccount, programId, provider, coder) {\n        this._idlAccount = idlAccount;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n        this._size = ACCOUNT_DISCRIMINATOR_SIZE + accountSize(idl, idlAccount);\n    }\n    /**\n     * Returns the number of bytes in this account.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetch(address) {\n        const accountInfo = await this._provider.connection.getAccountInfo(translateAddress(address));\n        if (accountInfo === null) {\n            throw new Error(`Account does not exist ${address.toString()}`);\n        }\n        // Assert the account discriminator is correct.\n        const discriminator = await accountDiscriminator(this._idlAccount.name);\n        if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n    }\n    /**\n     * Returns all instances of this account type for the program.\n     */\n    async all(filter) {\n        let bytes = await accountDiscriminator(this._idlAccount.name);\n        if (filter !== undefined) {\n            bytes = Buffer.concat([bytes, filter]);\n        }\n        let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n            commitment: this._provider.connection.commitment,\n            filters: [\n                {\n                    memcmp: {\n                        offset: 0,\n                        bytes: bs58.encode(bytes),\n                    },\n                },\n            ],\n        });\n        return resp.map(({ pubkey, account }) => {\n            return {\n                publicKey: pubkey,\n                account: this._coder.accounts.decode(this._idlAccount.name, account.data),\n            };\n        });\n    }\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n    subscribe(address, commitment) {\n        if (subscriptions.get(address.toString())) {\n            return subscriptions.get(address.toString()).ee;\n        }\n        const ee = new EventEmitter();\n        address = translateAddress(address);\n        const listener = this._provider.connection.onAccountChange(address, (acc) => {\n            const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        subscriptions.set(address.toString(), {\n            ee,\n            listener,\n        });\n        return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n    unsubscribe(address) {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n            console.warn(\"Address is not subscribed\");\n            return;\n        }\n        if (subscriptions) {\n            this._provider.connection\n                .removeAccountChangeListener(sub.listener)\n                .then(() => {\n                subscriptions.delete(address.toString());\n            })\n                .catch(console.error);\n        }\n    }\n    /**\n     * Returns an instruction for creating this account.\n     */\n    async createInstruction(signer, sizeOverride) {\n        const size = this.size;\n        return SystemProgram.createAccount({\n            fromPubkey: this._provider.wallet.publicKey,\n            newAccountPubkey: signer.publicKey,\n            space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n            programId: this._programId,\n        });\n    }\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n    async associated(...args) {\n        const addr = await this.associatedAddress(...args);\n        return await this.fetch(addr);\n    }\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated address. Args are keys to associate.\n     * Order matters.\n     */\n    async associatedAddress(...args) {\n        return await pubkeyUtil.associated(this._programId, ...args);\n    }\n}\n// Tracks all subscriptions.\nconst subscriptions = new Map();\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"module"}