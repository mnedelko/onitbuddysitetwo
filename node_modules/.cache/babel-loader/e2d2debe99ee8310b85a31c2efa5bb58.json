{"ast":null,"code":"import _toConsumableArray from\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _regeneratorRuntime from\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{Transaction}from'@solana/web3.js';import{WalletNotConnectedError}from'@solana/wallet-adapter-base';export var DEFAULT_TIMEOUT=60000;export var getErrorForTransaction=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection,txid){var tx,errors;return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return connection.confirmTransaction(txid,'max');case 2:_context.next=4;return connection.getParsedConfirmedTransaction(txid);case 4:tx=_context.sent;errors=[];if(tx!==null&&tx!==void 0&&tx.meta&&tx.meta.logMessages){tx.meta.logMessages.forEach(function(log){var regex=/Error: (.*)/gm;var m;while((m=regex.exec(log))!==null){// This is necessary to avoid infinite loops with zero-width matches\nif(m.index===regex.lastIndex){regex.lastIndex++;}if(m.length>1){errors.push(m[1]);}}});}return _context.abrupt(\"return\",errors);case 8:case\"end\":return _context.stop();}}},_callee);}));return function getErrorForTransaction(_x,_x2){return _ref.apply(this,arguments);};}();export var SequenceType;(function(SequenceType){SequenceType[SequenceType[\"Sequential\"]=0]=\"Sequential\";SequenceType[SequenceType[\"Parallel\"]=1]=\"Parallel\";SequenceType[SequenceType[\"StopOnFailure\"]=2]=\"StopOnFailure\";})(SequenceType||(SequenceType={}));export function sendTransactionsWithManualRetry(_x3,_x4,_x5,_x6){return _sendTransactionsWithManualRetry.apply(this,arguments);}function _sendTransactionsWithManualRetry(){_sendTransactionsWithManualRetry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(connection,wallet,instructions,signers){var stopPoint,tries,lastInstructionsLength,toRemoveSigners,ids,filteredSigners,id,_yield$sendTransactio,txs;return _regeneratorRuntime().wrap(function _callee5$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:stopPoint=0;tries=0;lastInstructionsLength=null;toRemoveSigners={};instructions=instructions.filter(function(instr,i){if(instr.length>0){return true;}else{toRemoveSigners[i]=true;return false;}});ids=[];filteredSigners=signers.filter(function(_,i){return!toRemoveSigners[i];});case 7:if(!(stopPoint<instructions.length&&tries<3)){_context6.next=33;break;}instructions=instructions.slice(stopPoint,instructions.length);filteredSigners=filteredSigners.slice(stopPoint,filteredSigners.length);if(instructions.length===lastInstructionsLength)tries=tries+1;else tries=0;_context6.prev=11;if(!(instructions.length===1)){_context6.next=20;break;}_context6.next=15;return sendTransactionWithRetry(connection,wallet,instructions[0],filteredSigners[0],'single');case 15:id=_context6.sent;ids.push(id.txid);stopPoint=1;_context6.next=25;break;case 20:_context6.next=22;return sendTransactions(connection,wallet,instructions,filteredSigners,SequenceType.StopOnFailure,'single');case 22:_yield$sendTransactio=_context6.sent;txs=_yield$sendTransactio.txs;ids=ids.concat(txs.map(function(t){return t.txid;}));case 25:_context6.next=30;break;case 27:_context6.prev=27;_context6.t0=_context6[\"catch\"](11);console.error(_context6.t0);case 30:/* console.log(\n        'Died on ',\n        stopPoint,\n        'retrying from instruction',\n        instructions[stopPoint],\n        'instructions length is',\n        instructions.length,\n      ); */lastInstructionsLength=instructions.length;_context6.next=7;break;case 33:return _context6.abrupt(\"return\",ids);case 34:case\"end\":return _context6.stop();}}},_callee5,null,[[11,27]]);}));return _sendTransactionsWithManualRetry.apply(this,arguments);}export var sendTransactions=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connection,wallet,instructionSet,signersSet){var sequenceType,commitment,successCallback,failCallback,block,beforeTransactions,afterTransactions,unsignedTxns,_loop,i,_ret,partiallySignedTransactions,fullySignedTransactions,signedTxns,pendingTxns,_loop2,_i,_ret2,result,_args3=arguments;return _regeneratorRuntime().wrap(function _callee2$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:sequenceType=_args3.length>4&&_args3[4]!==undefined?_args3[4]:SequenceType.Parallel;commitment=_args3.length>5&&_args3[5]!==undefined?_args3[5]:'singleGossip';successCallback=_args3.length>6&&_args3[6]!==undefined?_args3[6]:function(txid,ind){};failCallback=_args3.length>7&&_args3[7]!==undefined?_args3[7]:function(txid,ind){return false;};block=_args3.length>8?_args3[8]:undefined;beforeTransactions=_args3.length>9&&_args3[9]!==undefined?_args3[9]:[];afterTransactions=_args3.length>10&&_args3[10]!==undefined?_args3[10]:[];if(wallet.publicKey){_context3.next=9;break;}throw new WalletNotConnectedError();case 9:unsignedTxns=beforeTransactions;if(block){_context3.next=14;break;}_context3.next=13;return connection.getRecentBlockhash(commitment);case 13:block=_context3.sent;case 14:_loop=function _loop(i){var instructions=instructionSet[i];var signers=signersSet[i];if(instructions.length===0){return\"continue\";}var transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});transaction.recentBlockhash=block.blockhash;transaction.setSigners.apply(transaction,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));if(signers.length>0){transaction.partialSign.apply(transaction,_toConsumableArray(signers));}unsignedTxns.push(transaction);};i=0;case 16:if(!(i<instructionSet.length)){_context3.next=23;break;}_ret=_loop(i);if(!(_ret===\"continue\")){_context3.next=20;break;}return _context3.abrupt(\"continue\",20);case 20:i++;_context3.next=16;break;case 23:unsignedTxns.push.apply(unsignedTxns,_toConsumableArray(afterTransactions));partiallySignedTransactions=unsignedTxns.filter(function(t){return t.signatures.find(function(sig){return sig.publicKey.equals(wallet.publicKey);});});fullySignedTransactions=unsignedTxns.filter(function(t){return!t.signatures.find(function(sig){return sig.publicKey.equals(wallet.publicKey);});});_context3.next=28;return wallet.signAllTransactions(partiallySignedTransactions);case 28:signedTxns=_context3.sent;signedTxns=fullySignedTransactions.concat(signedTxns);pendingTxns=[];/* console.log(\n      'Signed txns length',\n      signedTxns.length,\n      'vs handed in length',\n      instructionSet.length,\n    ); */_loop2=/*#__PURE__*/_regeneratorRuntime().mark(function _loop2(_i){var signedTxnPromise;return _regeneratorRuntime().wrap(function _loop2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:signedTxnPromise=sendSignedTransaction({connection:connection,signedTransaction:signedTxns[_i]});if(!(sequenceType!==SequenceType.Parallel)){_context2.next=20;break;}_context2.prev=2;_context2.next=5;return signedTxnPromise.then(function(_ref3){var txid=_ref3.txid,slot=_ref3.slot;return successCallback(txid,_i);});case 5:pendingTxns.push(signedTxnPromise);_context2.next=18;break;case 8:_context2.prev=8;_context2.t0=_context2[\"catch\"](2);//console.log('Failed at txn index:', i);\n//console.log('Caught failure:', e);\nfailCallback(signedTxns[_i],_i);if(!(sequenceType===SequenceType.StopOnFailure)){_context2.next=18;break;}_context2.t1=_i;_context2.next=15;return Promise.all(pendingTxns);case 15:_context2.t2=_context2.sent;_context2.t3={number:_context2.t1,txs:_context2.t2};return _context2.abrupt(\"return\",{v:_context2.t3});case 18:_context2.next=21;break;case 20:pendingTxns.push(signedTxnPromise);case 21:case\"end\":return _context2.stop();}}},_loop2,null,[[2,8]]);});_i=0;case 33:if(!(_i<signedTxns.length)){_context3.next=41;break;}return _context3.delegateYield(_loop2(_i),\"t0\",35);case 35:_ret2=_context3.t0;if(!(typeof _ret2===\"object\")){_context3.next=38;break;}return _context3.abrupt(\"return\",_ret2.v);case 38:_i++;_context3.next=33;break;case 41:if(!(sequenceType!==SequenceType.Parallel)){_context3.next=46;break;}_context3.next=44;return Promise.all(pendingTxns);case 44:result=_context3.sent;return _context3.abrupt(\"return\",{number:signedTxns.length,txs:result});case 46:_context3.t1=signedTxns.length;_context3.next=49;return Promise.all(pendingTxns);case 49:_context3.t2=_context3.sent;return _context3.abrupt(\"return\",{number:_context3.t1,txs:_context3.t2});case 51:case\"end\":return _context3.stop();}}},_callee2);}));return function sendTransactions(_x7,_x8,_x9,_x10){return _ref2.apply(this,arguments);};}();export var sendTransaction=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(connection,wallet,instructions,signers){var awaitConfirmation,commitment,includesFeePayer,block,transaction,_transaction,_transaction2,_transaction3,rawTransaction,options,txid,slot,confirmation,errors,_args4=arguments;return _regeneratorRuntime().wrap(function _callee3$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:awaitConfirmation=_args4.length>4&&_args4[4]!==undefined?_args4[4]:true;commitment=_args4.length>5&&_args4[5]!==undefined?_args4[5]:'singleGossip';includesFeePayer=_args4.length>6&&_args4[6]!==undefined?_args4[6]:false;block=_args4.length>7?_args4[7]:undefined;if(wallet.publicKey){_context4.next=6;break;}throw new WalletNotConnectedError();case 6:if(Array.isArray(instructions)){_context4.next=10;break;}transaction=instructions;_context4.next=24;break;case 10:transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});_context4.t0=block;if(_context4.t0){_context4.next=17;break;}_context4.next=16;return connection.getRecentBlockhash(commitment);case 16:_context4.t0=_context4.sent;case 17:transaction.recentBlockhash=_context4.t0.blockhash;if(includesFeePayer){(_transaction=transaction).setSigners.apply(_transaction,_toConsumableArray(signers.map(function(s){return s.publicKey;})));}else{(_transaction2=transaction).setSigners.apply(_transaction2,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));}if(signers.length>0){(_transaction3=transaction).partialSign.apply(_transaction3,_toConsumableArray(signers));}if(includesFeePayer){_context4.next=24;break;}_context4.next=23;return wallet.signTransaction(transaction);case 23:transaction=_context4.sent;case 24:rawTransaction=transaction.serialize();options={skipPreflight:true,commitment:commitment};_context4.next=28;return connection.sendRawTransaction(rawTransaction,options);case 28:txid=_context4.sent;slot=0;if(!awaitConfirmation){_context4.next=43;break;}_context4.next=33;return awaitTransactionSignatureConfirmation(txid,DEFAULT_TIMEOUT,connection,commitment);case 33:confirmation=_context4.sent;if(confirmation){_context4.next=36;break;}throw new Error('Timed out awaiting confirmation on transaction');case 36:slot=(confirmation===null||confirmation===void 0?void 0:confirmation.slot)||0;if(!(confirmation!==null&&confirmation!==void 0&&confirmation.err)){_context4.next=43;break;}_context4.next=40;return getErrorForTransaction(connection,txid);case 40:errors=_context4.sent;console.log(errors);throw new Error(\"Raw transaction \".concat(txid,\" failed\"));case 43:return _context4.abrupt(\"return\",{txid:txid,slot:slot});case 44:case\"end\":return _context4.stop();}}},_callee3);}));return function sendTransaction(_x11,_x12,_x13,_x14){return _ref4.apply(this,arguments);};}();export var sendTransactionWithRetry=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(connection,wallet,instructions,signers){var commitment,includesFeePayer,block,beforeSend,transaction,_transaction4,_transaction5,_transaction6,_yield$sendSignedTran,txid,slot,_args5=arguments;return _regeneratorRuntime().wrap(function _callee4$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:commitment=_args5.length>4&&_args5[4]!==undefined?_args5[4]:'singleGossip';includesFeePayer=_args5.length>5&&_args5[5]!==undefined?_args5[5]:false;block=_args5.length>6?_args5[6]:undefined;beforeSend=_args5.length>7?_args5[7]:undefined;if(wallet.publicKey){_context5.next=6;break;}throw new WalletNotConnectedError();case 6:if(Array.isArray(instructions)){_context5.next=10;break;}transaction=instructions;_context5.next=24;break;case 10:transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});_context5.t0=block;if(_context5.t0){_context5.next=17;break;}_context5.next=16;return connection.getRecentBlockhash(commitment);case 16:_context5.t0=_context5.sent;case 17:transaction.recentBlockhash=_context5.t0.blockhash;if(includesFeePayer){(_transaction4=transaction).setSigners.apply(_transaction4,_toConsumableArray(signers.map(function(s){return s.publicKey;})));}else{(_transaction5=transaction).setSigners.apply(_transaction5,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));}if(signers.length>0){(_transaction6=transaction).partialSign.apply(_transaction6,_toConsumableArray(signers));}if(includesFeePayer){_context5.next=24;break;}_context5.next=23;return wallet.signTransaction(transaction);case 23:transaction=_context5.sent;case 24:if(beforeSend){beforeSend();}_context5.next=27;return sendSignedTransaction({connection:connection,signedTransaction:transaction});case 27:_yield$sendSignedTran=_context5.sent;txid=_yield$sendSignedTran.txid;slot=_yield$sendSignedTran.slot;return _context5.abrupt(\"return\",{txid:txid,slot:slot});case 31:case\"end\":return _context5.stop();}}},_callee4);}));return function sendTransactionWithRetry(_x15,_x16,_x17,_x18){return _ref5.apply(this,arguments);};}();export var getUnixTs=function getUnixTs(){return new Date().getTime()/1000;};export function sendSignedTransaction(_x19){return _sendSignedTransaction.apply(this,arguments);}function _sendSignedTransaction(){_sendSignedTransaction=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref6){var signedTransaction,connection,_ref6$timeout,timeout,rawTransaction,startTime,slot,txid,done,confirmation,simulateResult,i,line;return _regeneratorRuntime().wrap(function _callee7$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:signedTransaction=_ref6.signedTransaction,connection=_ref6.connection,_ref6$timeout=_ref6.timeout,timeout=_ref6$timeout===void 0?DEFAULT_TIMEOUT:_ref6$timeout;rawTransaction=signedTransaction.serialize();startTime=getUnixTs();slot=0;_context8.next=6;return connection.sendRawTransaction(rawTransaction,{skipPreflight:true});case 6:txid=_context8.sent;//console.log('Started awaiting confirmation for', txid);\ndone=false;_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(){return _regeneratorRuntime().wrap(function _callee6$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:if(!(!done&&getUnixTs()-startTime<timeout)){_context7.next=6;break;}connection.sendRawTransaction(rawTransaction,{skipPreflight:true});_context7.next=4;return sleep(500);case 4:_context7.next=0;break;case 6:case\"end\":return _context7.stop();}}},_callee6);}))();_context8.prev=9;_context8.next=12;return awaitTransactionSignatureConfirmation(txid,timeout,connection,'recent',true);case 12:confirmation=_context8.sent;if(confirmation){_context8.next=15;break;}throw new Error('Timed out awaiting confirmation on transaction');case 15:if(!confirmation.err){_context8.next=18;break;}console.error(confirmation.err);throw new Error('Transaction failed: Custom instruction error');case 18:slot=(confirmation===null||confirmation===void 0?void 0:confirmation.slot)||0;_context8.next=46;break;case 21:_context8.prev=21;_context8.t0=_context8[\"catch\"](9);console.error('Timeout Error caught',_context8.t0);if(!_context8.t0.timeout){_context8.next=26;break;}throw new Error('Timed out awaiting confirmation on transaction');case 26:simulateResult=null;_context8.prev=27;_context8.next=30;return simulateTransaction(connection,signedTransaction,'single');case 30:simulateResult=_context8.sent.value;_context8.next=35;break;case 33:_context8.prev=33;_context8.t1=_context8[\"catch\"](27);case 35:if(!(simulateResult&&simulateResult.err)){_context8.next=46;break;}if(!simulateResult.logs){_context8.next=45;break;}i=simulateResult.logs.length-1;case 38:if(!(i>=0)){_context8.next=45;break;}line=simulateResult.logs[i];if(!line.startsWith('Program log: ')){_context8.next=42;break;}throw new Error('Transaction failed: '+line.slice('Program log: '.length));case 42:--i;_context8.next=38;break;case 45:throw new Error(JSON.stringify(simulateResult.err));case 46:_context8.prev=46;done=true;return _context8.finish(46);case 49:return _context8.abrupt(\"return\",{txid:txid,slot:slot});case 50:case\"end\":return _context8.stop();}}},_callee7,null,[[9,21,46,49],[27,33]]);}));return _sendSignedTransaction.apply(this,arguments);}function simulateTransaction(_x20,_x21,_x22){return _simulateTransaction.apply(this,arguments);}function _simulateTransaction(){_simulateTransaction=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(connection,transaction,commitment){var signData,wireTransaction,encodedTransaction,config,args,res;return _regeneratorRuntime().wrap(function _callee8$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return connection._recentBlockhash(// @ts-ignore\nconnection._disableBlockhashCaching);case 2:transaction.recentBlockhash=_context9.sent;signData=transaction.serializeMessage();// @ts-ignore\nwireTransaction=transaction._serialize(signData);encodedTransaction=wireTransaction.toString('base64');config={encoding:'base64',commitment:commitment};args=[encodedTransaction,config];// @ts-ignore\n_context9.next=10;return connection._rpcRequest('simulateTransaction',args);case 10:res=_context9.sent;if(!res.error){_context9.next=13;break;}throw new Error('failed to simulate transaction: '+res.error.message);case 13:return _context9.abrupt(\"return\",res.result);case 14:case\"end\":return _context9.stop();}}},_callee8);}));return _simulateTransaction.apply(this,arguments);}function awaitTransactionSignatureConfirmation(_x23,_x24,_x25){return _awaitTransactionSignatureConfirmation.apply(this,arguments);}function _awaitTransactionSignatureConfirmation(){_awaitTransactionSignatureConfirmation=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(txid,timeout,connection){var commitment,queryStatus,done,status,subId,_args12=arguments;return _regeneratorRuntime().wrap(function _callee11$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:commitment=_args12.length>3&&_args12[3]!==undefined?_args12[3]:'recent';queryStatus=_args12.length>4&&_args12[4]!==undefined?_args12[4]:false;done=false;status={slot:0,confirmations:0,err:null};subId=0;_context12.next=7;return new Promise(/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(resolve,reject){return _regeneratorRuntime().wrap(function _callee10$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:setTimeout(function(){if(done){return;}done=true;//console.log('Rejecting for timeout...');\nreject({timeout:true});},timeout);try{subId=connection.onSignature(txid,function(result,context){done=true;status={err:result.err,slot:context.slot,confirmations:0};if(result.err){//console.log('Rejected via websocket', result.err);\nreject(status);}else{//console.log('Resolved via websocket', result);\nresolve(status);}},commitment);}catch(e){done=true;console.error('WS error in setup',txid,e);}case 2:if(!(!done&&queryStatus)){_context11.next=8;break;}// eslint-disable-next-line no-loop-func\n_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(){var signatureStatuses;return _regeneratorRuntime().wrap(function _callee9$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_context10.prev=0;_context10.next=3;return connection.getSignatureStatuses([txid]);case 3:signatureStatuses=_context10.sent;status=signatureStatuses&&signatureStatuses.value[0];if(!done){if(!status){console.log('REST null result for',txid,status);}else if(status.err){//console.log('REST error for', txid, status);\ndone=true;reject(status.err);}else if(!status.confirmations){//console.log('REST no confirmations for', txid, status);\n}else{//console.log('REST confirmation for', txid, status);\ndone=true;resolve(status);}}_context10.next=11;break;case 8:_context10.prev=8;_context10.t0=_context10[\"catch\"](0);if(!done){//console.log('REST connection error: txid', txid, e);\n}case 11:case\"end\":return _context10.stop();}}},_callee9,null,[[0,8]]);}))();_context11.next=6;return sleep(2000);case 6:_context11.next=2;break;case 8:case\"end\":return _context11.stop();}}},_callee10);}));return function(_x26,_x27){return _ref8.apply(this,arguments);};}());case 7:status=_context12.sent;//@ts-ignore\ntry{connection.removeSignatureListener(subId);}catch(e){// ignore\n}done=true;//console.log('Returning status', status);\nreturn _context12.abrupt(\"return\",status);case 11:case\"end\":return _context12.stop();}}},_callee11);}));return _awaitTransactionSignatureConfirmation.apply(this,arguments);}export function sleep(ms){return new Promise(function(resolve){return setTimeout(resolve,ms);});}","map":{"version":3,"names":["Transaction","WalletNotConnectedError","DEFAULT_TIMEOUT","getErrorForTransaction","connection","txid","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","log","regex","m","exec","index","lastIndex","length","push","SequenceType","sendTransactionsWithManualRetry","wallet","instructions","signers","stopPoint","tries","lastInstructionsLength","toRemoveSigners","filter","instr","i","ids","filteredSigners","_","slice","sendTransactionWithRetry","id","sendTransactions","StopOnFailure","txs","concat","map","t","console","error","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","beforeTransactions","afterTransactions","publicKey","unsignedTxns","getRecentBlockhash","transaction","instruction","add","recentBlockhash","blockhash","setSigners","s","partialSign","partiallySignedTransactions","signatures","find","sig","equals","fullySignedTransactions","signAllTransactions","signedTxns","pendingTxns","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","Promise","all","number","result","sendTransaction","awaitConfirmation","includesFeePayer","Array","isArray","signTransaction","rawTransaction","serialize","options","skipPreflight","sendRawTransaction","awaitTransactionSignatureConfirmation","confirmation","Error","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","sleep","simulateResult","simulateTransaction","value","logs","line","startsWith","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding","args","_rpcRequest","res","message","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","removeSignatureListener","ms"],"sources":["/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/src/connection.tsx"],"sourcesContent":["import {\n    Keypair,\n    Commitment,\n    Connection,\n    RpcResponseAndContext,\n    SignatureStatus,\n    SimulatedTransactionResponse,\n    Transaction,\n    TransactionInstruction,\n    TransactionSignature,\n    Blockhash,\n    FeeCalculator,\n  } from '@solana/web3.js';\n  \n  import { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n  \n  interface BlockhashAndFeeCalculator {\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n  }\n  \n  export const DEFAULT_TIMEOUT = 60000;\n  \n  export const getErrorForTransaction = async (\n    connection: Connection,\n    txid: string,\n  ) => {\n    // wait for all confirmation before geting transaction\n    await connection.confirmTransaction(txid, 'max');\n  \n    const tx = await connection.getParsedConfirmedTransaction(txid);\n  \n    const errors: string[] = [];\n    if (tx?.meta && tx.meta.logMessages) {\n      tx.meta.logMessages.forEach(log => {\n        const regex = /Error: (.*)/gm;\n        let m;\n        while ((m = regex.exec(log)) !== null) {\n          // This is necessary to avoid infinite loops with zero-width matches\n          if (m.index === regex.lastIndex) {\n            regex.lastIndex++;\n          }\n  \n          if (m.length > 1) {\n            errors.push(m[1]);\n          }\n        }\n      });\n    }\n  \n    return errors;\n  };\n  \n  export enum SequenceType {\n    Sequential,\n    Parallel,\n    StopOnFailure,\n  }\n  \n  export async function sendTransactionsWithManualRetry(\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[][],\n    signers: Keypair[][],\n  ): Promise<(string | undefined)[]> {\n    let stopPoint = 0;\n    let tries = 0;\n    let lastInstructionsLength = null;\n    let toRemoveSigners: Record<number, boolean> = {};\n    instructions = instructions.filter((instr, i) => {\n      if (instr.length > 0) {\n        return true;\n      } else {\n        toRemoveSigners[i] = true;\n        return false;\n      }\n    });\n    let ids: string[] = [];\n    let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n  \n    while (stopPoint < instructions.length && tries < 3) {\n      instructions = instructions.slice(stopPoint, instructions.length);\n      filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n  \n      if (instructions.length === lastInstructionsLength) tries = tries + 1;\n      else tries = 0;\n  \n      try {\n        if (instructions.length === 1) {\n          const id = await sendTransactionWithRetry(\n            connection,\n            wallet,\n            instructions[0],\n            filteredSigners[0],\n            'single',\n          );\n          ids.push(id.txid);\n          stopPoint = 1;\n        } else {\n          const { txs } = await sendTransactions(\n            connection,\n            wallet,\n            instructions,\n            filteredSigners,\n            SequenceType.StopOnFailure,\n            'single',\n          );\n          ids = ids.concat(txs.map(t => t.txid));\n        }\n      } catch (e) {\n        console.error(e);\n      }\n      /* console.log(\n        'Died on ',\n        stopPoint,\n        'retrying from instruction',\n        instructions[stopPoint],\n        'instructions length is',\n        instructions.length,\n      ); */\n      lastInstructionsLength = instructions.length;\n    }\n  \n    return ids;\n  }\n  \n  export const sendTransactions = async (\n    connection: Connection,\n    wallet: any,\n    instructionSet: TransactionInstruction[][],\n    signersSet: Keypair[][],\n    sequenceType: SequenceType = SequenceType.Parallel,\n    commitment: Commitment = 'singleGossip',\n    successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n    failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n    block?: BlockhashAndFeeCalculator,\n    beforeTransactions: Transaction[] = [],\n    afterTransactions: Transaction[] = [],\n  ): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n  \n    const unsignedTxns: Transaction[] = beforeTransactions;\n  \n    if (!block) {\n      block = await connection.getRecentBlockhash(commitment);\n    }\n  \n    for (let i = 0; i < instructionSet.length; i++) {\n      const instructions = instructionSet[i];\n      const signers = signersSet[i];\n  \n      if (instructions.length === 0) {\n        continue;\n      }\n  \n      let transaction = new Transaction();\n      instructions.forEach(instruction => transaction.add(instruction));\n      transaction.recentBlockhash = block.blockhash;\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n  \n      if (signers.length > 0) {\n        transaction.partialSign(...signers);\n      }\n  \n      unsignedTxns.push(transaction);\n    }\n    unsignedTxns.push(...afterTransactions);\n\n  const partiallySignedTransactions = unsignedTxns.filter(t =>\n      t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  const fullySignedTransactions = unsignedTxns.filter(\n      t => !t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  let signedTxns = await wallet.signAllTransactions(\n      partiallySignedTransactions,\n  );\n  signedTxns = fullySignedTransactions.concat(signedTxns);\n    const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n  \n    /* console.log(\n      'Signed txns length',\n      signedTxns.length,\n      'vs handed in length',\n      instructionSet.length,\n    ); */\n    for (let i = 0; i < signedTxns.length; i++) {\n      const signedTxnPromise = sendSignedTransaction({\n        connection,\n        signedTransaction: signedTxns[i],\n      });\n  \n      if (sequenceType !== SequenceType.Parallel) {\n        try {\n          await signedTxnPromise.then(({ txid, slot }) =>\n            successCallback(txid, i),\n        );\n        pendingTxns.push(signedTxnPromise);\n        } catch (e) {\n          //console.log('Failed at txn index:', i);\n          //console.log('Caught failure:', e);\n\n          failCallback(signedTxns[i], i);\n          if (sequenceType === SequenceType.StopOnFailure) {\n            return {\n              number: i,\n              txs: await Promise.all(pendingTxns),\n            };\n          }\n        }\n      } else {\n        pendingTxns.push(signedTxnPromise);\n      }\n    }\n  \n    if (sequenceType !== SequenceType.Parallel) {\n      const result = await Promise.all(pendingTxns);\n      return { number: signedTxns.length, txs: result };\n    }\n  \n    return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n  };\n  \n  export const sendTransaction = async (\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[] | Transaction,\n    signers: Keypair[],\n    awaitConfirmation = true,\n    commitment: Commitment = 'singleGossip',\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator,\n  ) => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n  \n    let transaction: Transaction;\n    if (!Array.isArray(instructions)) {\n      transaction = instructions;\n    } else {\n      transaction = new Transaction();\n      instructions.forEach(instruction => transaction.add(instruction));\n      transaction.recentBlockhash = (\n        block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n  \n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n  \n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  }  \n\n  const rawTransaction = transaction.serialize();\n    let options = {\n      skipPreflight: true,\n      commitment,\n    };\n  \n    const txid = await connection.sendRawTransaction(rawTransaction, options);\n    let slot = 0;\n  \n    if (awaitConfirmation) {\n      const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        DEFAULT_TIMEOUT,\n        connection,\n        commitment,\n      );\n  \n      if (!confirmation)\n        throw new Error('Timed out awaiting confirmation on transaction');\n      slot = confirmation?.slot || 0;\n  \n      if (confirmation?.err) {\n        const errors = await getErrorForTransaction(connection, txid);\n  \n        console.log(errors);\n        throw new Error(`Raw transaction ${txid} failed`);\n      }\n    }\n  \n    return { txid, slot };\n  };\n  \n  export const sendTransactionWithRetry = async (\n    connection: Connection,\n    wallet: any,\n    instructions: Transaction | TransactionInstruction[],\n    signers: Keypair[],\n    commitment: Commitment = 'singleGossip',\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator,\n    beforeSend?: () => void,\n  ) => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n  \n    let transaction: Transaction;\n    if (!Array.isArray(instructions)) {\n      transaction = instructions;\n    } else {\n      transaction = new Transaction();\n      instructions.forEach(instruction => transaction.add(instruction));\n      transaction.recentBlockhash = (\n        block || (await connection.getRecentBlockhash(commitment))\n      ).blockhash;\n    \n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n  \n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  }\n\n\n    if (beforeSend) {\n      beforeSend();\n    }\n  \n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n  \n    return { txid, slot };\n  };\n  \n  export const getUnixTs = () => {\n    return new Date().getTime() / 1000;\n  };\n  \n  export async function sendSignedTransaction({\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT,\n  }: {\n    signedTransaction: Transaction;\n    connection: Connection;\n    sendingMessage?: string;\n    sentMessage?: string;\n    successMessage?: string;\n    timeout?: number;\n  }): Promise<{ txid: string; slot: number }> {\n    const rawTransaction = signedTransaction.serialize();\n\n    const startTime = getUnixTs();\n    let slot = 0;\n    const txid: TransactionSignature = await connection.sendRawTransaction(\n      rawTransaction,\n      {\n        skipPreflight: true,\n      },\n    );\n  \n    //console.log('Started awaiting confirmation for', txid);\n  \n    let done = false;\n    (async () => {\n      while (!done && getUnixTs() - startTime < timeout) {\n        connection.sendRawTransaction(rawTransaction, {\n          skipPreflight: true,\n        });\n        await sleep(500);\n      }\n    })();\n    try {\n      const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        timeout,\n        connection,\n        'recent',\n        true,\n      );\n  \n      if (!confirmation)\n        throw new Error('Timed out awaiting confirmation on transaction');\n  \n      if (confirmation.err) {\n        console.error(confirmation.err);\n        throw new Error('Transaction failed: Custom instruction error');\n      }\n  \n      slot = confirmation?.slot || 0;\n    } catch (err: any) {\n      console.error('Timeout Error caught', err);\n      if (err.timeout) {\n        throw new Error('Timed out awaiting confirmation on transaction');\n      }\n      let simulateResult: SimulatedTransactionResponse | null = null;\n      try {\n        simulateResult = (\n          await simulateTransaction(connection, signedTransaction, 'single')\n        ).value;\n      } catch (e) {}\n      if (simulateResult && simulateResult.err) {\n        if (simulateResult.logs) {\n          for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n            const line = simulateResult.logs[i];\n            if (line.startsWith('Program log: ')) {\n              throw new Error(\n                'Transaction failed: ' + line.slice('Program log: '.length),\n              );\n            }\n          }\n        }\n        throw new Error(JSON.stringify(simulateResult.err));\n      }\n      // throw new Error('Transaction failed');\n    } finally {\n      done = true;\n    }\n  \n    //console.log('Latency', txid, getUnixTs() - startTime);\n    return { txid, slot };\n  }\n  \n  async function simulateTransaction(\n    connection: Connection,\n    transaction: Transaction,\n    commitment: Commitment,\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    // @ts-ignore\n    transaction.recentBlockhash = await connection._recentBlockhash(\n      // @ts-ignore\n      connection._disableBlockhashCaching,\n    );\n  \n    const signData = transaction.serializeMessage();\n    // @ts-ignore\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString('base64');\n    const config: any = { encoding: 'base64', commitment };\n    const args = [encodedTransaction, config];\n  \n    // @ts-ignore\n    const res = await connection._rpcRequest('simulateTransaction', args);\n    if (res.error) {\n      throw new Error('failed to simulate transaction: ' + res.error.message);\n    }\n    return res.result;\n  }\n  \n  async function awaitTransactionSignatureConfirmation(\n    txid: TransactionSignature,\n    timeout: number,\n    connection: Connection,\n    commitment: Commitment = 'recent',\n    queryStatus = false,\n  ): Promise<SignatureStatus | null | void> {\n    let done = false;\n    let status: SignatureStatus | null | void = {\n      slot: 0,\n      confirmations: 0,\n      err: null,\n    };\n    let subId = 0;\n    status = await new Promise(async (resolve, reject) => {\n      setTimeout(() => {\n        if (done) {\n          return;\n        }\n        done = true;\n        //console.log('Rejecting for timeout...');\n        reject({ timeout: true });\n      }, timeout);\n      try {\n        subId = connection.onSignature(\n          txid,\n          (result, context) => {\n            done = true;\n            status = {\n              err: result.err,\n              slot: context.slot,\n              confirmations: 0,\n            };\n            if (result.err) {\n              //console.log('Rejected via websocket', result.err);\n              reject(status);\n            } else {\n              //console.log('Resolved via websocket', result);\n              resolve(status);\n            }\n          },\n          commitment,\n        );\n      } catch (e) {\n        done = true;\n        console.error('WS error in setup', txid, e);\n      }\n      while (!done && queryStatus) {\n        // eslint-disable-next-line no-loop-func\n        (async () => {\n          try {\n            const signatureStatuses = await connection.getSignatureStatuses([\n              txid,\n            ]);\n            status = signatureStatuses && signatureStatuses.value[0];\n            if (!done) {\n              if (!status) {\n                console.log('REST null result for', txid, status);\n              } else if (status.err) {\n                //console.log('REST error for', txid, status);\n                done = true;\n                reject(status.err);\n              } else if (!status.confirmations) {\n                //console.log('REST no confirmations for', txid, status);\n              } else {\n                //console.log('REST confirmation for', txid, status);\n                done = true;\n                resolve(status);\n              }\n            }\n          } catch (e) {\n            if (!done) {\n              //console.log('REST connection error: txid', txid, e);\n            }\n          }\n        })();\n        await sleep(2000);\n      }\n    });\n  \n    //@ts-ignore\n    try {\n      connection.removeSignatureListener(subId);\n    } catch (e) {\n      // ignore\n    }\n    done = true;\n    //console.log('Returning status', status);\n    return status;\n  }\n\n  export function sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n"],"mappings":"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"},"metadata":{},"sourceType":"module"}