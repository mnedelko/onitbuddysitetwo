{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport assert from \"assert\";\nimport { PublicKey, Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\";\nimport { getProvider } from \"../provider\";\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nexport function invoke(_x, _x2, _x3, _x4) {\n  return _invoke.apply(this, arguments);\n}\nfunction _invoke() {\n  _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(programId, accounts, data, provider) {\n    var tx;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            programId = translateAddress(programId);\n            if (!provider) {\n              provider = getProvider();\n            }\n            tx = new Transaction();\n            tx.add(new TransactionInstruction({\n              programId: programId,\n              keys: accounts !== null && accounts !== void 0 ? accounts : [],\n              data: data\n            }));\n            _context.next = 6;\n            return provider.send(tx);\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _invoke.apply(this, arguments);\n}\nexport function getMultipleAccounts(_x5, _x6) {\n  return _getMultipleAccounts.apply(this, arguments);\n}\nfunction _getMultipleAccounts() {\n  _getMultipleAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connection, publicKeys) {\n    var args, res, accounts, _iterator, _step, account, value, executable, owner, lamports, data;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            args = [publicKeys.map(function (k) {\n              return k.toBase58();\n            }), {\n              commitment: \"recent\"\n            }]; // @ts-ignore\n            _context2.next = 3;\n            return connection._rpcRequest(\"getMultipleAccounts\", args);\n          case 3:\n            res = _context2.sent;\n            if (!res.error) {\n              _context2.next = 6;\n              break;\n            }\n            throw new Error(\"failed to get info about accounts \" + publicKeys.map(function (k) {\n              return k.toBase58();\n            }).join(\", \") + \": \" + res.error.message);\n          case 6:\n            assert(typeof res.result !== \"undefined\");\n            accounts = [];\n            _iterator = _createForOfIteratorHelper(res.result.value);\n            _context2.prev = 9;\n            _iterator.s();\n          case 11:\n            if ((_step = _iterator.n()).done) {\n              _context2.next = 23;\n              break;\n            }\n            account = _step.value;\n            value = null;\n            if (!(account === null)) {\n              _context2.next = 17;\n              break;\n            }\n            accounts.push(null);\n            return _context2.abrupt(\"continue\", 21);\n          case 17:\n            if (res.result.value) {\n              executable = account.executable, owner = account.owner, lamports = account.lamports, data = account.data;\n              assert(data[1] === \"base64\");\n              value = {\n                executable: executable,\n                owner: new PublicKey(owner),\n                lamports: lamports,\n                data: Buffer.from(data[0], \"base64\")\n              };\n            }\n            if (!(value === null)) {\n              _context2.next = 20;\n              break;\n            }\n            throw new Error(\"Invalid response\");\n          case 20:\n            accounts.push(value);\n          case 21:\n            _context2.next = 11;\n            break;\n          case 23:\n            _context2.next = 28;\n            break;\n          case 25:\n            _context2.prev = 25;\n            _context2.t0 = _context2[\"catch\"](9);\n            _iterator.e(_context2.t0);\n          case 28:\n            _context2.prev = 28;\n            _iterator.f();\n            return _context2.finish(28);\n          case 31:\n            return _context2.abrupt(\"return\", accounts.map(function (account, idx) {\n              if (account === null) {\n                return null;\n              }\n              return {\n                publicKey: publicKeys[idx],\n                account: account\n              };\n            }));\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[9, 25, 28, 31]]);\n  }));\n  return _getMultipleAccounts.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/utils/rpc.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import assert from \"assert\";\nimport { PublicKey, Transaction, TransactionInstruction, } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\";\nimport { getProvider } from \"../provider\";\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nexport async function invoke(programId, accounts, data, provider) {\n    programId = translateAddress(programId);\n    if (!provider) {\n        provider = getProvider();\n    }\n    const tx = new Transaction();\n    tx.add(new TransactionInstruction({\n        programId,\n        keys: accounts !== null && accounts !== void 0 ? accounts : [],\n        data,\n    }));\n    return await provider.send(tx);\n}\nexport async function getMultipleAccounts(connection, publicKeys) {\n    const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n    // @ts-ignore\n    const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n    if (res.error) {\n        throw new Error(\"failed to get info about accounts \" +\n            publicKeys.map((k) => k.toBase58()).join(\", \") +\n            \": \" +\n            res.error.message);\n    }\n    assert(typeof res.result !== \"undefined\");\n    const accounts = [];\n    for (const account of res.result.value) {\n        let value = null;\n        if (account === null) {\n            accounts.push(null);\n            continue;\n        }\n        if (res.result.value) {\n            const { executable, owner, lamports, data } = account;\n            assert(data[1] === \"base64\");\n            value = {\n                executable,\n                owner: new PublicKey(owner),\n                lamports,\n                data: Buffer.from(data[0], \"base64\"),\n            };\n        }\n        if (value === null) {\n            throw new Error(\"Invalid response\");\n        }\n        accounts.push(value);\n    }\n    return accounts.map((account, idx) => {\n        if (account === null) {\n            return null;\n        }\n        return {\n            publicKey: publicKeys[idx],\n            account,\n        };\n    });\n}\n//# sourceMappingURL=rpc.js.map"]},"metadata":{},"sourceType":"module"}