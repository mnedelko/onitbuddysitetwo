{"ast":null,"code":"import _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as base64 from \"base64-js\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlCoder } from \"./idl\";\nexport var EventCoder = /*#__PURE__*/function () {\n  function EventCoder(idl) {\n    _classCallCheck(this, EventCoder);\n    if (idl.events === undefined) {\n      this.layouts = new Map();\n      return;\n    }\n    var layouts = idl.events.map(function (event) {\n      var eventTypeDef = {\n        name: event.name,\n        type: {\n          kind: \"struct\",\n          fields: event.fields.map(function (f) {\n            return {\n              name: f.name,\n              type: f.type\n            };\n          })\n        }\n      };\n      return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n    });\n    // @ts-ignore\n    this.layouts = new Map(layouts);\n    this.discriminators = new Map(idl.events === undefined ? [] : idl.events.map(function (e) {\n      return [base64.fromByteArray(eventDiscriminator(e.name)), e.name];\n    }));\n  }\n  _createClass(EventCoder, [{\n    key: \"decode\",\n    value: function decode(log) {\n      var logArr;\n      // This will throw if log length is not a multiple of 4.\n      try {\n        logArr = Buffer.from(base64.toByteArray(log));\n      } catch (e) {\n        return null;\n      }\n      var disc = base64.fromByteArray(logArr.slice(0, 8));\n      // Only deserialize if the discriminator implies a proper event.\n      var eventName = this.discriminators.get(disc);\n      if (eventName === undefined) {\n        return null;\n      }\n      var layout = this.layouts.get(eventName);\n      var data = layout.decode(logArr.slice(8));\n      return {\n        data: data,\n        name: eventName\n      };\n    }\n  }]);\n  return EventCoder;\n}();\nexport function eventDiscriminator(name) {\n  return Buffer.from(sha256.digest(\"event:\".concat(name))).slice(0, 8);\n}","map":{"version":3,"sources":["../../../src/coder/event.ts"],"names":[],"mappings":";;AAAA,OAAO,KAAK,MAAM,MAAM,WAAW;AAEnC,SAAS,MAAM,QAAQ,WAAW;AAGlC,SAAS,QAAQ,QAAQ,OAAO;AAEhC,WAAa,UAAU;EAWrB,oBAAmB,GAAQ,EAAA;IAAA;IACzB,IAAI,GAAG,CAAC,MAAM,KAAK,SAAS,EAAE;MAC5B,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE;MACxB;IACD;IACD,IAAM,OAAO,GAAG,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,KAAK,EAAI;MACvC,IAAI,YAAY,GAAe;QAC7B,IAAI,EAAE,KAAK,CAAC,IAAI;QAChB,IAAI,EAAE;UACJ,IAAI,EAAE,QAAQ;UACd,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,CAAC,EAAI;YAC7B,OAAO;cAAE,IAAI,EAAE,CAAC,CAAC,IAAI;cAAE,IAAI,EAAE,CAAC,CAAC;YAAI,CAAE;UACvC,CAAC;QACF;OACF;MACD,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,aAAa,CAAC,YAAY,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;IACtE,CAAC,CAAC;IACF;IACA,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC;IAE/B,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,CAC3B,GAAG,CAAC,MAAM,KAAK,SAAS,GACpB,EAAE,GACF,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,CAAC;MAAA,OAAK,CACpB,MAAM,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAChD,CAAC,CAAC,IAAI,CACP;IAAA,EAAC,CACP;EACH;EAAC;IAAA;IAAA,OAEM,gBAAO,GAAW,EAAA;MACvB,IAAI,MAAc;MAClB;MACA,IAAI;QACF,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;OAC9C,CAAC,OAAO,CAAC,EAAE;QACV,OAAO,IAAI;MACZ;MACD,IAAM,IAAI,GAAG,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAErD;MACA,IAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC;MAC/C,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,OAAO,IAAI;MACZ;MAED,IAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC;MAC1C,IAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;MAC3C,OAAO;QAAE,IAAI,EAAJ,IAAI;QAAE,IAAI,EAAE;MAAS,CAAE;IAClC;EAAC;EAAA;AAAA;AAGH,OAAM,SAAU,kBAAkB,CAAC,IAAY,EAAA;EAC7C,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,iBAAU,IAAI,EAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;AAChE","sourceRoot":"","sourcesContent":["import * as base64 from \"base64-js\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlCoder } from \"./idl\";\nexport class EventCoder {\n    constructor(idl) {\n        if (idl.events === undefined) {\n            this.layouts = new Map();\n            return;\n        }\n        const layouts = idl.events.map((event) => {\n            let eventTypeDef = {\n                name: event.name,\n                type: {\n                    kind: \"struct\",\n                    fields: event.fields.map((f) => {\n                        return { name: f.name, type: f.type };\n                    }),\n                },\n            };\n            return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];\n        });\n        // @ts-ignore\n        this.layouts = new Map(layouts);\n        this.discriminators = new Map(idl.events === undefined\n            ? []\n            : idl.events.map((e) => [\n                base64.fromByteArray(eventDiscriminator(e.name)),\n                e.name,\n            ]));\n    }\n    decode(log) {\n        let logArr;\n        // This will throw if log length is not a multiple of 4.\n        try {\n            logArr = Buffer.from(base64.toByteArray(log));\n        }\n        catch (e) {\n            return null;\n        }\n        const disc = base64.fromByteArray(logArr.slice(0, 8));\n        // Only deserialize if the discriminator implies a proper event.\n        const eventName = this.discriminators.get(disc);\n        if (eventName === undefined) {\n            return null;\n        }\n        const layout = this.layouts.get(eventName);\n        const data = layout.decode(logArr.slice(8));\n        return { data, name: eventName };\n    }\n}\nexport function eventDiscriminator(name) {\n    return Buffer.from(sha256.digest(`event:${name}`)).slice(0, 8);\n}\n//# sourceMappingURL=event.js.map"]},"metadata":{},"sourceType":"module"}