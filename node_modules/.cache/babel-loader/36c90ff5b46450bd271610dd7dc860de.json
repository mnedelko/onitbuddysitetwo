{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { IdlCoder } from \"./idl\";\nimport { sha256 } from \"js-sha256\";\n/**\n * Number of bytes of the account discriminator.\n */\nexport var ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Encodes and decodes account objects.\n */\nexport var AccountsCoder = /*#__PURE__*/function () {\n  function AccountsCoder(idl) {\n    _classCallCheck(this, AccountsCoder);\n    if (idl.accounts === undefined) {\n      this.accountLayouts = new Map();\n      return;\n    }\n    var layouts = idl.accounts.map(function (acc) {\n      return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n    });\n    this.accountLayouts = new Map(layouts);\n  }\n  _createClass(AccountsCoder, [{\n    key: \"encode\",\n    value: function () {\n      var _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(accountName, account) {\n        var buffer, layout, len, accountData, discriminator;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n                layout = this.accountLayouts.get(accountName);\n                len = layout.encode(account, buffer);\n                accountData = buffer.slice(0, len);\n                _context.next = 6;\n                return accountDiscriminator(accountName);\n              case 6:\n                discriminator = _context.sent;\n                return _context.abrupt(\"return\", Buffer.concat([discriminator, accountData]));\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function encode(_x, _x2) {\n        return _encode.apply(this, arguments);\n      }\n      return encode;\n    }()\n  }, {\n    key: \"decode\",\n    value: function decode(accountName, ix) {\n      // Chop off the discriminator before decoding.\n      var data = ix.slice(8);\n      var layout = this.accountLayouts.get(accountName);\n      return layout.decode(data);\n    }\n  }]);\n  return AccountsCoder;\n}();\n// Calculates unique 8 byte discriminator prepended to all anchor accounts.\nexport function accountDiscriminator(_x3) {\n  return _accountDiscriminator.apply(this, arguments);\n}\nfunction _accountDiscriminator() {\n  _accountDiscriminator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", Buffer.from(sha256.digest(\"account:\".concat(name))).slice(0, 8));\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _accountDiscriminator.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/coder/accounts.ts"],"names":[],"mappings":";;;;AAEA,SAAS,QAAQ,QAAQ,OAAO;AAChC,SAAS,MAAM,QAAQ,WAAW;AAElC;;AAEG;AACH,OAAO,IAAM,0BAA0B,GAAG,CAAC;AAE3C;;AAEG;AACH,WAAa,aAAa;EAMxB,uBAAmB,GAAQ,EAAA;IAAA;IACzB,IAAI,GAAG,CAAC,QAAQ,KAAK,SAAS,EAAE;MAC9B,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,EAAE;MAC/B;IACD;IACD,IAAM,OAAO,GAAuB,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAC,GAAG,EAAI;MAC3D,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;IAC3D,CAAC,CAAC;IAEF,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC;EACxC;EAAC;IAAA;IAAA;MAAA,yEAEM,iBACL,WAAmB,EACnB,OAAU;QAAA;QAAA;UAAA;YAAA;cAAA;gBAEJ,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBAC7B,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC;gBAC7C,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC;gBACtC,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC;gBAAA;gBAAA,OACZ,oBAAoB,CAAC,WAAW,CAAC;cAAA;gBAAvD,aAAa;gBAAA,iCACV,MAAM,CAAC,MAAM,CAAC,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACnD;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAEM,gBAAgB,WAAmB,EAAE,EAAU,EAAA;MACpD;MACA,IAAM,IAAI,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;MACxB,IAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC;MACnD,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;IAC5B;EAAC;EAAA;AAAA;AAGH;AACA,gBAAsB,oBAAoB;EAAA;AAAA;AAEzC;EAAA,mFAFM,kBAAoC,IAAY;IAAA;MAAA;QAAA;UAAA;YAAA,kCAC9C,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,mBAAY,IAAI,EAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACjE;EAAA;AAAA","sourceRoot":"","sourcesContent":["import { IdlCoder } from \"./idl\";\nimport { sha256 } from \"js-sha256\";\n/**\n * Number of bytes of the account discriminator.\n */\nexport const ACCOUNT_DISCRIMINATOR_SIZE = 8;\n/**\n * Encodes and decodes account objects.\n */\nexport class AccountsCoder {\n    constructor(idl) {\n        if (idl.accounts === undefined) {\n            this.accountLayouts = new Map();\n            return;\n        }\n        const layouts = idl.accounts.map((acc) => {\n            return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];\n        });\n        this.accountLayouts = new Map(layouts);\n    }\n    async encode(accountName, account) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.accountLayouts.get(accountName);\n        const len = layout.encode(account, buffer);\n        let accountData = buffer.slice(0, len);\n        let discriminator = await accountDiscriminator(accountName);\n        return Buffer.concat([discriminator, accountData]);\n    }\n    decode(accountName, ix) {\n        // Chop off the discriminator before decoding.\n        const data = ix.slice(8);\n        const layout = this.accountLayouts.get(accountName);\n        return layout.decode(data);\n    }\n}\n// Calculates unique 8 byte discriminator prepended to all anchor accounts.\nexport async function accountDiscriminator(name) {\n    return Buffer.from(sha256.digest(`account:${name}`)).slice(0, 8);\n}\n//# sourceMappingURL=accounts.js.map"]},"metadata":{},"sourceType":"module"}