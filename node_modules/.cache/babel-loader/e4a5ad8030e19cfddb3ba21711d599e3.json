{"ast":null,"code":"import _objectSpread from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\nexport var SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport var SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nexport var InstructionCoder = /*#__PURE__*/function () {\n  function InstructionCoder(idl) {\n    var _this = this;\n    _classCallCheck(this, InstructionCoder);\n    this.idl = idl;\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    var sighashLayouts = new Map();\n    idl.instructions.forEach(function (ix) {\n      var sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: _this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n    if (idl.state) {\n      idl.state.methods.map(function (ix) {\n        var sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: _this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n  _createClass(InstructionCoder, [{\n    key: \"encode\",\n    value: function encode(ixName, ix) {\n      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n  }, {\n    key: \"encodeState\",\n    value: function encodeState(ixName, ix) {\n      return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(nameSpace, ixName, ix) {\n      var buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n      var methodName = camelCase(ixName);\n      var len = this.ixLayout.get(methodName).encode(ix, buffer);\n      var data = buffer.slice(0, len);\n      return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n  }, {\n    key: \"decode\",\n    value:\n    /**\n     * Dewcodes a program instruction.\n     */\n    function decode(ix) {\n      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n      if (typeof ix === \"string\") {\n        ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n      }\n      var sighash = bs58.encode(ix.slice(0, 8));\n      var data = ix.slice(8);\n      var decoder = this.sighashLayouts.get(sighash);\n      if (!decoder) {\n        return null;\n      }\n      return {\n        data: decoder.layout.decode(data),\n        name: decoder.name\n      };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n  }, {\n    key: \"format\",\n    value: function format(ix, accountMetas) {\n      return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n  }], [{\n    key: \"parseIxLayout\",\n    value: function parseIxLayout(idl) {\n      var stateMethods = idl.state ? idl.state.methods : [];\n      var ixLayouts = stateMethods.map(function (m) {\n        var fieldLayouts = m.args.map(function (arg) {\n          var _a, _b;\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(m.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }).concat(idl.instructions.map(function (ix) {\n        var fieldLayouts = ix.args.map(function (arg) {\n          var _a, _b;\n          return IdlCoder.fieldLayout(arg, Array.from([].concat(_toConsumableArray((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), _toConsumableArray((_b = idl.types) !== null && _b !== void 0 ? _b : []))));\n        });\n        var name = camelCase(ix.name);\n        return [name, borsh.struct(fieldLayouts, name)];\n      }));\n      // @ts-ignore\n      return new Map(ixLayouts);\n    }\n  }]);\n  return InstructionCoder;\n}();\nvar InstructionFormatter = /*#__PURE__*/function () {\n  function InstructionFormatter() {\n    _classCallCheck(this, InstructionFormatter);\n  }\n  _createClass(InstructionFormatter, null, [{\n    key: \"format\",\n    value: function format(ix, accountMetas, idl) {\n      var idlIx = idl.instructions.filter(function (i) {\n        return ix.name === i.name;\n      })[0];\n      if (idlIx === undefined) {\n        console.error(\"Invalid instruction given\");\n        return null;\n      }\n      var args = idlIx.args.map(function (idlField) {\n        return {\n          name: idlField.name,\n          type: InstructionFormatter.formatIdlType(idlField.type),\n          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n        };\n      });\n      var flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n      var accounts = accountMetas.map(function (meta, idx) {\n        if (idx < flatIdlAccounts.length) {\n          return _objectSpread({\n            name: flatIdlAccounts[idx].name\n          }, meta);\n        }\n        // \"Remaining accounts\" are unnamed in Anchor.\n        else {\n          return _objectSpread({\n            name: undefined\n          }, meta);\n        }\n      });\n      return {\n        args: args,\n        accounts: accounts\n      };\n    }\n  }, {\n    key: \"formatIdlType\",\n    value: function formatIdlType(idlType) {\n      if (typeof idlType === \"string\") {\n        return idlType;\n      }\n      // @ts-ignore\n      if (idlType.vec) {\n        // @ts-ignore\n        return \"Vec<\".concat(this.formatIdlType(idlType.vec), \">\");\n      }\n      // @ts-ignore\n      if (idlType.option) {\n        // @ts-ignore\n        return \"Option<\".concat(this.formatIdlType(idlType.option), \">\");\n      }\n      // @ts-ignore\n      if (idlType.defined) {\n        // @ts-ignore\n        return idlType.defined;\n      }\n    }\n  }, {\n    key: \"formatIdlData\",\n    value: function formatIdlData(idlField, data, types) {\n      var _this2 = this;\n      if (typeof idlField.type === \"string\") {\n        return data.toString();\n      }\n      // @ts-ignore\n      if (idlField.type.vec) {\n        // @ts-ignore\n        return \"[\" + data\n        // @ts-ignore\n        .map(function (d) {\n          return _this2.formatIdlData(\n          // @ts-ignore\n          {\n            name: \"\",\n            type: idlField.type.vec\n          }, d);\n        }).join(\", \") + \"]\";\n      }\n      // @ts-ignore\n      if (idlField.type.option) {\n        // @ts-ignore\n        return data === null ? \"null\" : this.formatIdlData(\n        // @ts-ignore\n        {\n          name: \"\",\n          type: idlField.type.option\n        }, data);\n      }\n      // @ts-ignore\n      if (idlField.type.defined) {\n        if (types === undefined) {\n          throw new Error(\"User defined types not provided\");\n        }\n        // @ts-ignore\n        var filtered = types.filter(function (t) {\n          return t.name === idlField.type.defined;\n        });\n        if (filtered.length !== 1) {\n          // @ts-ignore\n          throw new Error(\"Type not found: \".concat(idlField.type.defined));\n        }\n        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n      }\n      return \"unknown\";\n    }\n  }, {\n    key: \"formatIdlDataDefined\",\n    value: function formatIdlDataDefined(typeDef, data, types) {\n      if (typeDef.type.kind === \"struct\") {\n        var fields = Object.keys(data).map(function (k) {\n          var f = typeDef.type.fields.filter(function (f) {\n            return f.name === k;\n          })[0];\n          if (f === undefined) {\n            throw new Error(\"Unable to find type\");\n          }\n          return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n        }).join(\", \");\n        return \"{ \" + fields + \" }\";\n      } else {\n        if (typeDef.type.variants.length === 0) {\n          return \"{}\";\n        }\n        // Struct enum.\n        if (typeDef.type.variants[0].name) {\n          var variant = Object.keys(data)[0];\n          var enumType = data[variant];\n          var namedFields = Object.keys(enumType).map(function (f) {\n            var _a;\n            var fieldData = enumType[f];\n            var idlField = (_a = typeDef.type.variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(function (v) {\n              return v.name === f;\n            })[0];\n            if (idlField === undefined) {\n              throw new Error(\"Unable to find variant\");\n            }\n            return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n          }).join(\", \");\n          var variantName = camelCase(variant, {\n            pascalCase: true\n          });\n          if (namedFields.length === 0) {\n            return variantName;\n          }\n          return \"\".concat(variantName, \" { \").concat(namedFields, \" }\");\n        }\n        // Tuple enum.\n        else {\n          // TODO.\n          return \"Tuple formatting not yet implemented\";\n        }\n      }\n    }\n  }, {\n    key: \"flattenIdlAccounts\",\n    value: function flattenIdlAccounts(accounts, prefix) {\n      // @ts-ignore\n      return accounts.map(function (account) {\n        var accName = sentenceCase(account.name);\n        // @ts-ignore\n        if (account.accounts) {\n          var newPrefix = prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName;\n          // @ts-ignore\n          return InstructionFormatter.flattenIdlAccounts(\n          // @ts-ignore\n          account.accounts, newPrefix);\n        } else {\n          return _objectSpread(_objectSpread({}, account), {}, {\n            name: prefix ? \"\".concat(prefix, \" > \").concat(accName) : accName\n          });\n        }\n      }).flat();\n    }\n  }]);\n  return InstructionFormatter;\n}();\nfunction sentenceCase(field) {\n  var result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}","map":{"version":3,"sources":["../../../src/coder/instruction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nexport class InstructionCoder {\n    constructor(idl) {\n        this.idl = idl;\n        this.ixLayout = InstructionCoder.parseIxLayout(idl);\n        const sighashLayouts = new Map();\n        idl.instructions.forEach((ix) => {\n            const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n            sighashLayouts.set(bs58.encode(sh), {\n                layout: this.ixLayout.get(ix.name),\n                name: ix.name,\n            });\n        });\n        if (idl.state) {\n            idl.state.methods.map((ix) => {\n                const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n                sighashLayouts.set(bs58.encode(sh), {\n                    layout: this.ixLayout.get(ix.name),\n                    name: ix.name,\n                });\n            });\n        }\n        this.sighashLayouts = sighashLayouts;\n    }\n    /**\n     * Encodes a program instruction.\n     */\n    encode(ixName, ix) {\n        return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n    encodeState(ixName, ix) {\n        return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n    _encode(nameSpace, ixName, ix) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const methodName = camelCase(ixName);\n        const len = this.ixLayout.get(methodName).encode(ix, buffer);\n        const data = buffer.slice(0, len);\n        return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n    static parseIxLayout(idl) {\n        const stateMethods = idl.state ? idl.state.methods : [];\n        const ixLayouts = stateMethods\n            .map((m) => {\n            let fieldLayouts = m.args.map((arg) => {\n                var _a, _b;\n                return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n            });\n            const name = camelCase(m.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        })\n            .concat(idl.instructions.map((ix) => {\n            let fieldLayouts = ix.args.map((arg) => {\n                var _a, _b;\n                return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n            });\n            const name = camelCase(ix.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        }));\n        // @ts-ignore\n        return new Map(ixLayouts);\n    }\n    /**\n     * Dewcodes a program instruction.\n     */\n    decode(ix, encoding = \"hex\") {\n        if (typeof ix === \"string\") {\n            ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n        }\n        let sighash = bs58.encode(ix.slice(0, 8));\n        let data = ix.slice(8);\n        const decoder = this.sighashLayouts.get(sighash);\n        if (!decoder) {\n            return null;\n        }\n        return {\n            data: decoder.layout.decode(data),\n            name: decoder.name,\n        };\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n    format(ix, accountMetas) {\n        return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n}\nclass InstructionFormatter {\n    static format(ix, accountMetas, idl) {\n        const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];\n        if (idlIx === undefined) {\n            console.error(\"Invalid instruction given\");\n            return null;\n        }\n        const args = idlIx.args.map((idlField) => {\n            return {\n                name: idlField.name,\n                type: InstructionFormatter.formatIdlType(idlField.type),\n                data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types),\n            };\n        });\n        const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n        const accounts = accountMetas.map((meta, idx) => {\n            if (idx < flatIdlAccounts.length) {\n                return {\n                    name: flatIdlAccounts[idx].name,\n                    ...meta,\n                };\n            }\n            // \"Remaining accounts\" are unnamed in Anchor.\n            else {\n                return {\n                    name: undefined,\n                    ...meta,\n                };\n            }\n        });\n        return {\n            args,\n            accounts,\n        };\n    }\n    static formatIdlType(idlType) {\n        if (typeof idlType === \"string\") {\n            return idlType;\n        }\n        // @ts-ignore\n        if (idlType.vec) {\n            // @ts-ignore\n            return `Vec<${this.formatIdlType(idlType.vec)}>`;\n        }\n        // @ts-ignore\n        if (idlType.option) {\n            // @ts-ignore\n            return `Option<${this.formatIdlType(idlType.option)}>`;\n        }\n        // @ts-ignore\n        if (idlType.defined) {\n            // @ts-ignore\n            return idlType.defined;\n        }\n    }\n    static formatIdlData(idlField, data, types) {\n        if (typeof idlField.type === \"string\") {\n            return data.toString();\n        }\n        // @ts-ignore\n        if (idlField.type.vec) {\n            // @ts-ignore\n            return (\"[\" +\n                data\n                    // @ts-ignore\n                    .map((d) => this.formatIdlData(\n                // @ts-ignore\n                { name: \"\", type: idlField.type.vec }, d))\n                    .join(\", \") +\n                \"]\");\n        }\n        // @ts-ignore\n        if (idlField.type.option) {\n            // @ts-ignore\n            return data === null\n                ? \"null\"\n                : this.formatIdlData(\n                // @ts-ignore\n                { name: \"\", type: idlField.type.option }, data);\n        }\n        // @ts-ignore\n        if (idlField.type.defined) {\n            if (types === undefined) {\n                throw new Error(\"User defined types not provided\");\n            }\n            // @ts-ignore\n            const filtered = types.filter((t) => t.name === idlField.type.defined);\n            if (filtered.length !== 1) {\n                // @ts-ignore\n                throw new Error(`Type not found: ${idlField.type.defined}`);\n            }\n            return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n        }\n        return \"unknown\";\n    }\n    static formatIdlDataDefined(typeDef, data, types) {\n        if (typeDef.type.kind === \"struct\") {\n            const fields = Object.keys(data)\n                .map((k) => {\n                const f = typeDef.type.fields.filter((f) => f.name === k)[0];\n                if (f === undefined) {\n                    throw new Error(\"Unable to find type\");\n                }\n                return (k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types));\n            })\n                .join(\", \");\n            return \"{ \" + fields + \" }\";\n        }\n        else {\n            if (typeDef.type.variants.length === 0) {\n                return \"{}\";\n            }\n            // Struct enum.\n            if (typeDef.type.variants[0].name) {\n                const variant = Object.keys(data)[0];\n                const enumType = data[variant];\n                const namedFields = Object.keys(enumType)\n                    .map((f) => {\n                    var _a;\n                    const fieldData = enumType[f];\n                    const idlField = (_a = typeDef.type.variants[variant]) === null || _a === void 0 ? void 0 : _a.filter((v) => v.name === f)[0];\n                    if (idlField === undefined) {\n                        throw new Error(\"Unable to find variant\");\n                    }\n                    return (f +\n                        \": \" +\n                        InstructionFormatter.formatIdlData(idlField, fieldData, types));\n                })\n                    .join(\", \");\n                const variantName = camelCase(variant, { pascalCase: true });\n                if (namedFields.length === 0) {\n                    return variantName;\n                }\n                return `${variantName} { ${namedFields} }`;\n            }\n            // Tuple enum.\n            else {\n                // TODO.\n                return \"Tuple formatting not yet implemented\";\n            }\n        }\n    }\n    static flattenIdlAccounts(accounts, prefix) {\n        // @ts-ignore\n        return accounts\n            .map((account) => {\n            const accName = sentenceCase(account.name);\n            // @ts-ignore\n            if (account.accounts) {\n                const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n                // @ts-ignore\n                return InstructionFormatter.flattenIdlAccounts(\n                // @ts-ignore\n                account.accounts, newPrefix);\n            }\n            else {\n                return {\n                    ...account,\n                    name: prefix ? `${prefix} > ${accName}` : accName,\n                };\n            }\n        })\n            .flat();\n    }\n}\nfunction sentenceCase(field) {\n    const result = field.replace(/([A-Z])/g, \" $1\");\n    return result.charAt(0).toUpperCase() + result.slice(1);\n}\n//# sourceMappingURL=instruction.js.map"]},"metadata":{},"sourceType":"module"}