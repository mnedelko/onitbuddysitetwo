{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { getProvider } from \"../../\";\nimport { validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\nvar StateFactory = /*#__PURE__*/function () {\n  function StateFactory() {\n    _classCallCheck(this, StateFactory);\n  }\n  _createClass(StateFactory, null, [{\n    key: \"build\",\n    value: function build(idl, coder, programId, provider) {\n      if (idl.state === undefined) {\n        return undefined;\n      }\n      return new StateClient(idl, programId, provider, coder);\n    }\n  }]);\n  return StateFactory;\n}();\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nexport { StateFactory as default };\nexport var StateClient = /*#__PURE__*/function () {\n  function StateClient(idl, programId, provider, coder) {\n    _classCallCheck(this, StateClient);\n    this._idl = idl;\n    this._programId = programId;\n    this._address = programStateAddress(programId);\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n    this._sub = null;\n    // Build namespaces.\n    var _ref = function () {\n        var instruction = {};\n        var transaction = {};\n        var rpc = {};\n        idl.state.methods.forEach(function (m) {\n          // Build instruction method.\n          var ixItem = InstructionNamespaceFactory.build(m, function (ixName, ix) {\n            return coder.instruction.encodeState(ixName, ix);\n          }, programId);\n          ixItem[\"accounts\"] = function (accounts) {\n            var keys = stateInstructionKeys(programId, provider, m, accounts);\n            return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\n          };\n          // Build transaction method.\n          var txItem = TransactionNamespaceFactory.build(m, ixItem);\n          // Build RPC method.\n          var rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider);\n          // Attach them all to their respective namespaces.\n          var name = camelCase(m.name);\n          instruction[name] = ixItem;\n          transaction[name] = txItem;\n          rpc[name] = rpcItem;\n        });\n        return [instruction, transaction, rpc];\n      }(),\n      _ref2 = _slicedToArray(_ref, 3),\n      instruction = _ref2[0],\n      transaction = _ref2[1],\n      rpc = _ref2[2];\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.rpc = rpc;\n  }\n  /**\n   * Returns the program ID owning the state.\n   */\n  _createClass(StateClient, [{\n    key: \"programId\",\n    get: function get() {\n      return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n  }, {\n    key: \"coder\",\n    get: function get() {\n      return this._coder;\n    }\n    /**\n     * Returns the deserialized state account.\n     */\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var addr, accountInfo, expectedDiscriminator;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                addr = this.address();\n                _context.next = 3;\n                return this.provider.connection.getAccountInfo(addr);\n              case 3:\n                accountInfo = _context.sent;\n                if (!(accountInfo === null)) {\n                  _context.next = 6;\n                  break;\n                }\n                throw new Error(\"Account does not exist \".concat(addr.toString()));\n              case 6:\n                _context.next = 8;\n                return stateDiscriminator(this._idl.state.struct.name);\n              case 8:\n                expectedDiscriminator = _context.sent;\n                if (!expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n                  _context.next = 11;\n                  break;\n                }\n                throw new Error(\"Invalid account discriminator\");\n              case 11:\n                return _context.abrupt(\"return\", this.coder.state.decode(accountInfo.data));\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n    /**\n     * Returns the state address.\n     */\n  }, {\n    key: \"address\",\n    value: function address() {\n      return this._address;\n    }\n    /**\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n     * the state account cahnges.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(commitment) {\n      var _this = this;\n      if (this._sub !== null) {\n        return this._sub.ee;\n      }\n      var ee = new EventEmitter();\n      var listener = this.provider.connection.onAccountChange(this.address(), function (acc) {\n        var account = _this.coder.state.decode(acc.data);\n        ee.emit(\"change\", account);\n      }, commitment);\n      this._sub = {\n        ee: ee,\n        listener: listener\n      };\n      return ee;\n    }\n    /**\n     * Unsubscribes to state changes.\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n      if (this._sub !== null) {\n        this.provider.connection.removeAccountChangeListener(this._sub.listener).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _this2._sub = null;\n                case 1:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }))).catch(console.error);\n      }\n    }\n  }]);\n  return StateClient;\n}();\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n  var _findProgramAddressSy = findProgramAddressSync([], programId),\n    _findProgramAddressSy2 = _slicedToArray(_findProgramAddressSy, 1),\n    registrySigner = _findProgramAddressSy2[0];\n  return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n  if (m.name === \"new\") {\n    // Ctor `new` method.\n    var _findProgramAddressSy3 = findProgramAddressSync([], programId),\n      _findProgramAddressSy4 = _slicedToArray(_findProgramAddressSy3, 1),\n      programSigner = _findProgramAddressSy4[0];\n    return [{\n      pubkey: provider.wallet.publicKey,\n      isWritable: false,\n      isSigner: true\n    }, {\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: programSigner,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: SystemProgram.programId,\n      isWritable: false,\n      isSigner: false\n    }, {\n      pubkey: programId,\n      isWritable: false,\n      isSigner: false\n    }];\n  } else {\n    validateAccounts(m.accounts, accounts);\n    return [{\n      pubkey: programStateAddress(programId),\n      isWritable: true,\n      isSigner: false\n    }];\n  }\n}","map":{"version":3,"sources":["../../../../src/program/namespace/state.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport camelCase from \"camelcase\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { stateDiscriminator } from \"../../coder\";\nimport { getProvider } from \"../../\";\nimport { validateAccounts, parseIdlErrors } from \"../common\";\nimport { findProgramAddressSync, createWithSeedSync } from \"../../utils/pubkey\";\nimport InstructionNamespaceFactory from \"./instruction\";\nimport RpcNamespaceFactory from \"./rpc\";\nimport TransactionNamespaceFactory from \"./transaction\";\nexport default class StateFactory {\n    static build(idl, coder, programId, provider) {\n        if (idl.state === undefined) {\n            return undefined;\n        }\n        return new StateClient(idl, programId, provider, coder);\n    }\n}\n/**\n * A client for the program state. Similar to the base [[Program]] client,\n * one can use this to send transactions and read accounts for the state\n * abstraction.\n */\nexport class StateClient {\n    constructor(idl, programId, provider, coder) {\n        this._idl = idl;\n        this._programId = programId;\n        this._address = programStateAddress(programId);\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n        this._sub = null;\n        // Build namespaces.\n        const [instruction, transaction, rpc] = (() => {\n            let instruction = {};\n            let transaction = {};\n            let rpc = {};\n            idl.state.methods.forEach((m) => {\n                // Build instruction method.\n                const ixItem = InstructionNamespaceFactory.build(m, (ixName, ix) => coder.instruction.encodeState(ixName, ix), programId);\n                ixItem[\"accounts\"] = (accounts) => {\n                    const keys = stateInstructionKeys(programId, provider, m, accounts);\n                    return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts));\n                };\n                // Build transaction method.\n                const txItem = TransactionNamespaceFactory.build(m, ixItem);\n                // Build RPC method.\n                const rpcItem = RpcNamespaceFactory.build(m, txItem, parseIdlErrors(idl), provider);\n                // Attach them all to their respective namespaces.\n                const name = camelCase(m.name);\n                instruction[name] = ixItem;\n                transaction[name] = txItem;\n                rpc[name] = rpcItem;\n            });\n            return [instruction, transaction, rpc];\n        })();\n        this.instruction = instruction;\n        this.transaction = transaction;\n        this.rpc = rpc;\n    }\n    /**\n     * Returns the program ID owning the state.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Returns the deserialized state account.\n     */\n    async fetch() {\n        const addr = this.address();\n        const accountInfo = await this.provider.connection.getAccountInfo(addr);\n        if (accountInfo === null) {\n            throw new Error(`Account does not exist ${addr.toString()}`);\n        }\n        // Assert the account discriminator is correct.\n        const expectedDiscriminator = await stateDiscriminator(this._idl.state.struct.name);\n        if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this.coder.state.decode(accountInfo.data);\n    }\n    /**\n     * Returns the state address.\n     */\n    address() {\n        return this._address;\n    }\n    /**\n     * Returns an `EventEmitter` with a `\"change\"` event that's fired whenever\n     * the state account cahnges.\n     */\n    subscribe(commitment) {\n        if (this._sub !== null) {\n            return this._sub.ee;\n        }\n        const ee = new EventEmitter();\n        const listener = this.provider.connection.onAccountChange(this.address(), (acc) => {\n            const account = this.coder.state.decode(acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        this._sub = {\n            ee,\n            listener,\n        };\n        return ee;\n    }\n    /**\n     * Unsubscribes to state changes.\n     */\n    unsubscribe() {\n        if (this._sub !== null) {\n            this.provider.connection\n                .removeAccountChangeListener(this._sub.listener)\n                .then(async () => {\n                this._sub = null;\n            })\n                .catch(console.error);\n        }\n    }\n}\n// Calculates the deterministic address of the program's \"state\" account.\nfunction programStateAddress(programId) {\n    let [registrySigner] = findProgramAddressSync([], programId);\n    return createWithSeedSync(registrySigner, \"unversioned\", programId);\n}\n// Returns the common keys that are prepended to all instructions targeting\n// the \"state\" of a program.\nfunction stateInstructionKeys(programId, provider, m, accounts) {\n    if (m.name === \"new\") {\n        // Ctor `new` method.\n        const [programSigner] = findProgramAddressSync([], programId);\n        return [\n            {\n                pubkey: provider.wallet.publicKey,\n                isWritable: false,\n                isSigner: true,\n            },\n            {\n                pubkey: programStateAddress(programId),\n                isWritable: true,\n                isSigner: false,\n            },\n            { pubkey: programSigner, isWritable: false, isSigner: false },\n            {\n                pubkey: SystemProgram.programId,\n                isWritable: false,\n                isSigner: false,\n            },\n            { pubkey: programId, isWritable: false, isSigner: false },\n        ];\n    }\n    else {\n        validateAccounts(m.accounts, accounts);\n        return [\n            {\n                pubkey: programStateAddress(programId),\n                isWritable: true,\n                isSigner: false,\n            },\n        ];\n    }\n}\n//# sourceMappingURL=state.js.map"]},"metadata":{},"sourceType":"module"}