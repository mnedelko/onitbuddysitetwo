{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\nvar react_1 = require(\"react\");\nvar types_1 = require(\"../types\");\nvar logger_1 = __importDefault(require(\"../logger\"));\nvar useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'tokenOnChainNotFound':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED\n      });\n    case 'tokenOnChainError':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.ERROR\n      });\n    default:\n      return state;\n  }\n};\nexports.reducer = reducer;\nvar useChain = function useChain(_ref, state, dispatch) {\n  var wallet = _ref.wallet,\n    chainImplementation = _ref.chainImplementation,\n    networkConfig = _ref.networkConfig;\n  var _ref2 = (0, useWalletHooks_1.default)(wallet, state, dispatch),\n    expectWalletConnected = _ref2.expectWalletConnected;\n  var gatekeeperRecordState = state.gatekeeperRecordState,\n    gatewayToken = state.gatewayToken;\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useChain] \".concat(message), obj);\n  };\n  var logError = function logError(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(\"[useChain] \".concat(message), obj);\n  };\n  var removeOnChainListener = function removeOnChainListener(listernerId) {\n    try {\n      logDebug('Removing onChainListener with id: ', listernerId);\n      chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\n    } catch (error) {\n      logError('Error removing on chain listener', error);\n    }\n  };\n  /**\n   * listen to the blockchain for any token changes and update local state if there are\n   */\n  var addTokenChangeListeners =\n  /*#__PURE__*/\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(gatewayToken) {\n      var tokenChangeCallback, listernerId;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              tokenChangeCallback = function tokenChangeCallback(token) {\n                dispatch({\n                  type: 'tokenChange',\n                  token: token\n                });\n                dispatch({\n                  type: 'civicPass_check_token_status',\n                  token: token\n                });\n              };\n              _context.next = 3;\n              return chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\n            case 3:\n              listernerId = _context.sent;\n              logDebug('Adding onChainListener with id: ', listernerId);\n              return _context.abrupt(\"return\", listernerId);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return function addTokenChangeListeners(_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  (0, react_1.useEffect)(function () {\n    var listernerId;\n    var addListenerIfToken = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (gatewayToken) {\n                  addTokenChangeListeners(gatewayToken).then(function (id) {\n                    listernerId = id;\n                  }).catch(function (error) {\n                    logger_1.default.error('onChainListener error', error);\n                  });\n                }\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      return function addListenerIfToken() {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n    addListenerIfToken().catch(logger_1.default.error);\n    return function () {\n      if (listernerId) {\n        removeOnChainListener(listernerId);\n      }\n    };\n  }, [gatekeeperRecordState, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier]);\n  /**\n   * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\n   * when a token is found, set up listeners to monitor any on-chain changes\n   */\n  var dispatchTokenFromChain = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var connectedWallet, token, shouldDispatchTokenFromChain;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              connectedWallet = expectWalletConnected();\n              _context3.prev = 1;\n              logDebug('Fetching token from chain');\n              _context3.next = 5;\n              return chainImplementation.findGatewayToken();\n            case 5:\n              token = _context3.sent;\n              if (token) {\n                _context3.next = 9;\n                break;\n              }\n              dispatch({\n                type: 'tokenOnChainNotFound'\n              });\n              return _context3.abrupt(\"return\");\n            case 9:\n              logDebug('Token found', token);\n              dispatch({\n                type: 'tokenChange',\n                token: token\n              });\n              // Determine if we should show the civicPass dialog when we have a gateway token\n              shouldDispatchTokenFromChain = gatekeeperRecordState && [types_1.GatekeeperAPIStatus.ISSUED_EXPIRED, types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING, types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED, types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED].includes(gatekeeperRecordState);\n              if (shouldDispatchTokenFromChain) {\n                _context3.next = 14;\n                break;\n              }\n              return _context3.abrupt(\"return\");\n            case 14:\n              dispatch({\n                type: 'civicPass_check_token_status',\n                token: token\n              });\n              _context3.next = 22;\n              break;\n            case 17:\n              _context3.prev = 17;\n              _context3.t0 = _context3[\"catch\"](1);\n              logError(\"Error getting token from chain for \".concat(connectedWallet.publicKey), _context3.t0);\n              dispatch({\n                type: 'tokenOnChainError'\n              });\n              throw _context3.t0;\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[1, 17]]);\n    }));\n    return function dispatchTokenFromChain() {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  /**\n   * Determine if we should fetch a token from chain based on the gatekeeper record state\n   */\n  (0, react_1.useEffect)(function () {\n    var shouldDispatchTokenFromChain = gatekeeperRecordState && [types_1.GatekeeperAPIStatus.ISSUED, types_1.GatekeeperAPIStatus.ISSUED_EXPIRED, types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING, types_1.GatekeeperAPIStatus.REQUESTED, types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED, types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED, types_1.GatekeeperAPIStatus.SERVER_FAILURE].includes(gatekeeperRecordState);\n    if (!shouldDispatchTokenFromChain) return;\n    dispatchTokenFromChain();\n  }, [gatekeeperRecordState, chainImplementation]);\n  /**\n   * Check token on chain if checking the record status is not required\n   * This will then run when the component is mounted instead of after the record has been fetched\n   */\n  (0, react_1.useEffect)(function () {\n    if (networkConfig.requiresGatekeeperRecordStatusCheck) return;\n    dispatchTokenFromChain();\n  }, [networkConfig.requiresGatekeeperRecordStatusCheck, chainImplementation]);\n  return {\n    addTokenChangeListeners: addTokenChangeListeners,\n    dispatchTokenFromChain: dispatchTokenFromChain\n  };\n};\nexports.default = useChain;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","types_1","logger_1","useWalletHooks_1","state","action","type","assign","gatewayStatus","GatewayStatus","NOT_REQUESTED","ERROR","useChain","dispatch","wallet","chainImplementation","networkConfig","default","expectWalletConnected","gatekeeperRecordState","gatewayToken","logDebug","message","obj","debug","logError","error","removeOnChainListener","listernerId","removeOnGatewayTokenChangeListener","addTokenChangeListeners","tokenChangeCallback","token","addOnGatewayTokenChangeListener","useEffect","addListenerIfToken","then","id","catch","identifier","dispatchTokenFromChain","connectedWallet","findGatewayToken","shouldDispatchTokenFromChain","GatekeeperAPIStatus","ISSUED_EXPIRED","ISSUED_EXPIRY_APPROACHING","ISSUED_LOCATION_NOT_SUPPORTED","ISSUED_VPN_NOT_SUPPORTED","includes","publicKey","ISSUED","REQUESTED","SERVER_FAILURE","requiresGatekeeperRecordStatusCheck"],"sources":["/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@civic/common-gateway-react/dist/esm/useHooks/useChain.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'tokenOnChainNotFound':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED });\n        case 'tokenOnChainError':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.ERROR });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useChain = ({ wallet, chainImplementation, networkConfig, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const { gatekeeperRecordState, gatewayToken } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const removeOnChainListener = (listernerId) => {\n        try {\n            logDebug('Removing onChainListener with id: ', listernerId);\n            chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\n        }\n        catch (error) {\n            logError('Error removing on chain listener', error);\n        }\n    };\n    /**\n     * listen to the blockchain for any token changes and update local state if there are\n     */\n    const addTokenChangeListeners = \n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    async (gatewayToken) => {\n        const tokenChangeCallback = (token) => {\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n        };\n        const listernerId = await chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\n        logDebug('Adding onChainListener with id: ', listernerId);\n        return listernerId;\n    };\n    (0, react_1.useEffect)(() => {\n        let listernerId;\n        const addListenerIfToken = async () => {\n            if (gatewayToken) {\n                addTokenChangeListeners(gatewayToken)\n                    .then((id) => {\n                    listernerId = id;\n                })\n                    .catch((error) => {\n                    logger_1.default.error('onChainListener error', error);\n                });\n            }\n        };\n        addListenerIfToken().catch(logger_1.default.error);\n        return () => {\n            if (listernerId) {\n                removeOnChainListener(listernerId);\n            }\n        };\n    }, [gatekeeperRecordState, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier]);\n    /**\n     * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\n     * when a token is found, set up listeners to monitor any on-chain changes\n     */\n    const dispatchTokenFromChain = async () => {\n        const connectedWallet = expectWalletConnected();\n        try {\n            logDebug('Fetching token from chain');\n            const token = await chainImplementation.findGatewayToken();\n            if (!token) {\n                dispatch({ type: 'tokenOnChainNotFound' });\n                return;\n            }\n            logDebug('Token found', token);\n            dispatch({ type: 'tokenChange', token });\n            // Determine if we should show the civicPass dialog when we have a gateway token\n            const shouldDispatchTokenFromChain = gatekeeperRecordState &&\n                [\n                    types_1.GatekeeperAPIStatus.ISSUED_EXPIRED,\n                    types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING,\n                    types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED,\n                    types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED,\n                ].includes(gatekeeperRecordState);\n            if (!shouldDispatchTokenFromChain)\n                return;\n            dispatch({ type: 'civicPass_check_token_status', token });\n        }\n        catch (error) {\n            logError(`Error getting token from chain for ${connectedWallet.publicKey}`, error);\n            dispatch({ type: 'tokenOnChainError' });\n            throw error;\n        }\n    };\n    /**\n     * Determine if we should fetch a token from chain based on the gatekeeper record state\n     */\n    (0, react_1.useEffect)(() => {\n        const shouldDispatchTokenFromChain = gatekeeperRecordState &&\n            [\n                types_1.GatekeeperAPIStatus.ISSUED,\n                types_1.GatekeeperAPIStatus.ISSUED_EXPIRED,\n                types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING,\n                types_1.GatekeeperAPIStatus.REQUESTED,\n                types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED,\n                types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED,\n                types_1.GatekeeperAPIStatus.SERVER_FAILURE,\n            ].includes(gatekeeperRecordState);\n        if (!shouldDispatchTokenFromChain)\n            return;\n        dispatchTokenFromChain();\n    }, [gatekeeperRecordState, chainImplementation]);\n    /**\n     * Check token on chain if checking the record status is not required\n     * This will then run when the component is mounted instead of after the record has been fetched\n     */\n    (0, react_1.useEffect)(() => {\n        if (networkConfig.requiresGatekeeperRecordStatusCheck)\n            return;\n        dispatchTokenFromChain();\n    }, [networkConfig.requiresGatekeeperRecordStatusCheck, chainImplementation]);\n    return {\n        addTokenChangeListeners,\n        dispatchTokenFromChain,\n    };\n};\nexports.default = useChain;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}