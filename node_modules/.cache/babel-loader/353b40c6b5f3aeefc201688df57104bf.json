{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar react_1 = require(\"react\");\nvar logger_1 = __importDefault(require(\"../logger\"));\nvar types_1 = require(\"../types\");\nvar useChain_1 = __importDefault(require(\"./useChain\"));\nvar useRefresh_1 = __importDefault(require(\"./useRefresh\"));\nvar useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nvar actionCreator_1 = require(\"../actionCreator\");\nvar usePOWO_1 = __importDefault(require(\"./usePOWO\"));\nvar useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\nvar useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\nvar networkConfig_1 = __importDefault(require(\"../networkConfig\"));\nvar useCivicPass_1 = __importDefault(require(\"./useCivicPass\"));\nvar useCivicPassEventListener_1 = __importDefault(require(\"./useCivicPassEventListener\"));\nvar status_1 = require(\"../utils/status\");\nvar tokenUtils_1 = require(\"../utils/tokenUtils\");\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\nvar useOrchestration = function useOrchestration(_ref, state, dispatch) {\n  var wallet = _ref.wallet,\n    stage = _ref.stage,\n    chainImplementation = _ref.chainImplementation,\n    gatekeeperClient = _ref.gatekeeperClient;\n  var _ref2 = (0, useWalletHooks_1.default)(wallet, state, dispatch),\n    expectWalletConnected = _ref2.expectWalletConnected;\n  var gatewayToken = state.gatewayToken,\n    walletToRefresh = state.walletToRefresh,\n    civicPass = state.civicPass,\n    refreshTokenState = state.refreshTokenState,\n    gatewayStatus = state.gatewayStatus,\n    gatekeeperNetworkAddress = state.gatekeeperNetworkAddress,\n    ownerSigns = state.ownerSigns,\n    renderIframe = state.renderIframe,\n    refreshTimeoutId = state.refreshTimeoutId;\n  var networkConfig = (0, networkConfig_1.default)({\n    gatekeeperNetworkAddress: gatekeeperNetworkAddress,\n    stage: stage\n  });\n  // Register our hooks here\n  var _ref3 = (0, usePOWO_1.default)({\n      wallet: wallet,\n      chainImplementation: chainImplementation\n    }, state, dispatch),\n    waitForConfirmPOWO = _ref3.waitForConfirmPOWO,\n    waitForPOWO = _ref3.waitForPOWO,\n    waitForTransactionConfirm = _ref3.waitForTransactionConfirm,\n    waitForHandleTransaction = _ref3.waitForHandleTransaction;\n  var gatekeeperEndpoint = chainImplementation.httpConfig.baseUrl;\n  var _ref4 = (0, useGatekeeper_1.default)({\n      wallet: wallet,\n      stage: stage,\n      gatekeeperClient: gatekeeperClient\n    }, state, dispatch),\n    waitForGatekeeperIssuanceRequest = _ref4.waitForGatekeeperIssuanceRequest;\n  var _ref5 = (0, useRefresh_1.default)({\n      stage: stage,\n      gatekeeperClient: gatekeeperClient,\n      networkConfig: networkConfig\n    }, state, dispatch),\n    checkForRefreshWithTimeout = _ref5.checkForRefreshWithTimeout,\n    refreshToken = _ref5.refreshToken,\n    waitForUnexpiredGatewayToken = _ref5.waitForUnexpiredGatewayToken;\n  (0, useCivicPass_1.default)({\n    wallet: wallet\n  }, state, dispatch);\n  (0, useCivicPassEventListener_1.default)({\n    wallet: wallet,\n    chainImplementation: chainImplementation\n  });\n  (0, useChain_1.default)({\n    wallet: wallet,\n    chainImplementation: chainImplementation,\n    networkConfig: networkConfig\n  }, state, dispatch);\n  (0, useGatekeeperRecord_1.default)({\n    wallet: wallet,\n    gatekeeperClient: gatekeeperClient,\n    httpConfig: chainImplementation.httpConfig,\n    networkConfig: networkConfig\n  }, state, dispatch);\n  /**\n   * Refresh Flows ----------------------------------------------------------------\n   */\n  /**\n   * wait until we have a payload that has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n  var waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n      logger_1.default.debug('Refresh payload...', {\n        refreshPayload: refreshPayload,\n        refreshPayloadState: refreshPayload === undefined\n      });\n      if (refreshPayload !== undefined) {\n        logger_1.default.debug('Refreshing token...');\n        resolve(refreshPayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * When we have a token start check the next expiration so we can prompt the user to refresh\n   */\n  (0, react_1.useEffect)(function () {\n    logger_1.default.debug('useOrchestration', {\n      gatewayStatus: gatewayStatus && (0, status_1.statusDisplayValue)(gatewayStatus),\n      refreshTokenState: refreshTokenState && types_1.RefreshTokenState[refreshTokenState]\n    });\n    if (gatewayStatus === types_1.GatewayStatus.ACTIVE || refreshTokenState === types_1.RefreshTokenState.COMPLETED) {\n      logger_1.default.debug('Start polling for the refresh interval');\n      checkForRefreshWithTimeout(wallet);\n    }\n  }, [gatewayStatus, refreshTokenState, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, renderIframe]);\n  /**\n   * Whenever the iFrame is rendered, clear the timeout\n   */\n  (0, react_1.useEffect)(function () {\n    if (renderIframe && refreshTimeoutId) {\n      logger_1.default.debug('useEffect:dispatch refresh_clear_timeout');\n      clearTimeout(refreshTimeoutId);\n      dispatch({\n        type: 'refresh_clear_timeout'\n      });\n    }\n  }, [renderIframe, refreshTimeoutId]);\n  /**\n   * Issuance Flows ----------------------------------------------------------------\n   */\n  /**\n   * poll until a gatekeeper record is found, once active check the chain for a token\n   * then dispatch a tokenChange event that will result in the token getting saved to state\n   * start token refresh polling once a valid token is set\n   */\n  var waitForOnChainToken = (0, react_1.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var actionCreator;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!wallet) {\n              _context.next = 5;\n              break;\n            }\n            logger_1.default.debug('waitForOnChainToken');\n            actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n              wallet: wallet,\n              chainImplementation: chainImplementation,\n              gatekeeperClient: gatekeeperClient,\n              dispatch: dispatch,\n              networkConfig: networkConfig,\n              ownerSigns: ownerSigns\n            });\n            _context.next = 5;\n            return actionCreator.waitForGatewayToken();\n          case 5:\n            return _context.abrupt(\"return\", null);\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\n   * wait until a presentation request id has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n  var waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n      logger_1.default.debug('Issuance payload...', issuancePayload);\n      if (issuancePayload !== undefined) {\n        resolve(issuancePayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * wait until the user has requested a gateway token before resolving the promise\n   */\n  var checkForRequiredProof = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref7) {\n      var requiresProofOfWalletOwnership, payload, result;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              requiresProofOfWalletOwnership = _ref7.requiresProofOfWalletOwnership, payload = _ref7.payload;\n              logger_1.default.debug('Checking for required proof', {\n                requiresProofOfWalletOwnership: requiresProofOfWalletOwnership,\n                payload: payload\n              });\n              if (!requiresProofOfWalletOwnership) {\n                _context2.next = 7;\n                break;\n              }\n              _context2.next = 5;\n              return waitForConfirmPOWO(payload).then(waitForPOWO);\n            case 5:\n              result = _context2.sent;\n              return _context2.abrupt(\"return\", result);\n            case 7:\n              return _context2.abrupt(\"return\", {\n                payload: payload\n              });\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return function (_x) {\n      return _ref8.apply(this, arguments);\n    };\n  }(), [waitForConfirmPOWO, waitForPOWO]);\n  /**\n   * New token request flow !ownerSigns:\n   * wait for the user to request a new token\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to request a new token issuance\n   * wait for a gatekeeper record to be created\n   * once this flow is complete a new Gatekeeper token should be available and set in state\n   */\n  (0, react_1.useEffect)(function () {\n    if (!ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload !ownerSigns');\n      waitForCivicPassIssuanceResponsePayload().then(checkForRequiredProof).then(waitForGatekeeperIssuanceRequest).then(waitForOnChainToken).then(function () {\n        return checkForRefreshWithTimeout(wallet);\n      }).catch(function (error) {\n        dispatch({\n          type: 'civicPass_issuance_failure'\n        });\n        logger_1.default.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForOnChainToken, ownerSigns]);\n  /** Wrapper to pass through expected parameters when waiting for owner signs confirmation */\n  var confirmOwnerTransaction = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref9) {\n      var payload;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              payload = _ref9.payload;\n              _context3.next = 3;\n              return waitForTransactionConfirm();\n            case 3:\n              return _context3.abrupt(\"return\", {\n                payload: payload\n              });\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return function (_x2) {\n      return _ref10.apply(this, arguments);\n    };\n  }(), [waitForTransactionConfirm]);\n  /**\n   * Trigger the waiting for owner transaction state\n   * this function is a promise so it can be thenable\n   */\n  var showAwaitingOwnerTransaction = /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              logger_1.default.debug('showAwaitingOwnerTransaction');\n              dispatch({\n                type: 'civicPass_awaiting_owner_transaction'\n              });\n              return _context4.abrupt(\"return\", Promise.resolve());\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return function showAwaitingOwnerTransaction() {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n  /**\n   * New token request flow ownerSigns:\n   * wait for the user to request a new token\n   * wait for the iframe to return a payload\n   * wait for the user to confirm the transaction that they need to sign\n   * wait for a call to the gatekeeper to request a new token issuance\n   * wait for the handle transaction callback\n   * wait for a gatekeeper record to be created on chain\n   * once this flow is complete a new Gatekeeper token should be available and set in state\n   */\n  (0, react_1.useEffect)(function () {\n    if (ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload ownerSigns');\n      waitForCivicPassIssuanceResponsePayload().then(confirmOwnerTransaction).then(waitForGatekeeperIssuanceRequest).then(waitForHandleTransaction).then(showAwaitingOwnerTransaction).then(waitForOnChainToken).then(function () {\n        return checkForRefreshWithTimeout(wallet);\n      }).catch(function (error) {\n        // chain transaction errors will be handled using a different flow and dispatch event\n        if (!(error instanceof types_1.ChainTransactionError)) {\n          dispatch({\n            type: 'civicPass_issuance_failure'\n          });\n        }\n        logger_1.default.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForCivicPassIssuanceResponsePayload, confirmOwnerTransaction, waitForGatekeeperIssuanceRequest, waitForHandleTransaction, waitForOnChainToken, ownerSigns]);\n  /**\n   * Refresh start flow !ownerSigns:\n   * Triggered when we have a refreshResponse payload\n   * wait refresh to be triggered from the iFrame\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to refresh the token\n   * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n   */\n  (0, react_1.useEffect)(function () {\n    if (!ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload !ownerSigns');\n      var useWallet = walletToRefresh || wallet;\n      waitForCivicPassRefreshResponsePayload().then(checkForRequiredProof).then(refreshToken(useWallet)).then(function () {\n        return dispatch({\n          type: 'refresh_token_success'\n        });\n      }).catch(function (error) {\n        logger_1.default.error('refreshFlow', error);\n        dispatch({\n          type: 'civicPass_refresh_failure'\n        });\n      });\n    }\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, ownerSigns]);\n  /**\n   * Refresh start flow ownerSigns:\n   * Triggered when we have a refreshResponse payload\n   * wait refresh to be triggered from the iFrame\n   * wait for the iframe to return a payload\n   * wait for the handle transaction callback\n   * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n   */\n  (0, react_1.useEffect)(function () {\n    if (ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload ownerSigns');\n      var useWallet = walletToRefresh || wallet;\n      waitForCivicPassRefreshResponsePayload().then(refreshToken(useWallet)).then(waitForHandleTransaction).then(function () {\n        return dispatch({\n          type: 'refresh_token_success'\n        });\n      }).catch(function (error) {\n        // chain transaction errors will be handled using a different flow and dispatch event\n        if (!(error instanceof types_1.ChainTransactionError)) {\n          dispatch({\n            type: 'civicPass_refresh_failure'\n          });\n        }\n        logger_1.default.error('ERROR tokenRefreshFlow ownerSigns', error);\n      });\n    }\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, ownerSigns]);\n  /**\n   * Refresh complete flow:\n   * Triggered by token change event triggered from a call to the gatekeeper to refresh the token\n   * for owner signs case, dispatch an event to show the iframe chain-transaction confirming screen\n   * wait until the token is unexpired and clear timeout if token is not expired\n   * Complete the refresh event and clear the refresh response payload\n   */\n  (0, react_1.useEffect)(function () {\n    var useWallet = walletToRefresh || wallet;\n    if (refreshTokenState === types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN) {\n      logger_1.default.debug('useEffect: Refresh complete flow', {\n        expiryTime: gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,\n        hasExpired: (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) ? (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime) : 'unknown'\n      });\n      // if the dApp handles the transaction we shouldn't assume that the final state is 'unexpired' token\n      var optionalCheckUnexpired = chainImplementation.dAppHandlesTransactions && ownerSigns ? function () {\n        return Promise.resolve();\n      } : waitForUnexpiredGatewayToken;\n      optionalCheckUnexpired().then(function () {\n        return checkForRefreshWithTimeout(useWallet);\n      }).then(function () {\n        dispatch({\n          type: 'refresh_complete'\n        });\n        dispatch({\n          type: 'civicPass_check_token_status'\n        });\n      }).catch(function (error) {\n        logger_1.default.error('refreshFlow', error);\n        dispatch({\n          type: 'civicPass_refresh_failure'\n        });\n      });\n    }\n  }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, refreshTokenState, walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, ownerSigns]);\n};\nexports.default = useOrchestration;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","react_1","require","logger_1","types_1","useChain_1","useRefresh_1","useWalletHooks_1","actionCreator_1","usePOWO_1","useGatekeeper_1","useGatekeeperRecord_1","networkConfig_1","useCivicPass_1","useCivicPassEventListener_1","status_1","tokenUtils_1","useOrchestration","state","dispatch","wallet","stage","chainImplementation","gatekeeperClient","default","expectWalletConnected","gatewayToken","walletToRefresh","civicPass","refreshTokenState","gatewayStatus","gatekeeperNetworkAddress","ownerSigns","renderIframe","refreshTimeoutId","networkConfig","waitForConfirmPOWO","waitForPOWO","waitForTransactionConfirm","waitForHandleTransaction","gatekeeperEndpoint","httpConfig","baseUrl","waitForGatekeeperIssuanceRequest","checkForRefreshWithTimeout","refreshToken","waitForUnexpiredGatewayToken","waitForCivicPassRefreshResponsePayload","useCallback","debug","result","Promise","resolve","responsePayload","refreshPayload","CivicPassMessageAction","REFRESH","refreshPayloadState","undefined","useEffect","statusDisplayValue","RefreshTokenState","GatewayStatus","ACTIVE","COMPLETED","publicKey","clearTimeout","type","waitForOnChainToken","actionCreator","gatewayTokenActionCreator","waitForGatewayToken","waitForCivicPassIssuanceResponsePayload","issuancePayload","ISSUANCE","checkForRequiredProof","requiresProofOfWalletOwnership","payload","then","catch","error","confirmOwnerTransaction","showAwaitingOwnerTransaction","ChainTransactionError","useWallet","WAIT_FOR_ON_CHAIN","expiryTime","hasExpired","optionalCheckUnexpired","dAppHandlesTransactions","identifier"],"sources":["/Users/mnedelko/Library/Mobile Documents/com~apple~CloudDocs/Documents/comparativesite/onitbuddyprod/node_modules/@civic/common-gateway-react/dist/esm/useHooks/useOrchestration.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = require(\"react\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst useChain_1 = __importDefault(require(\"./useChain\"));\nconst useRefresh_1 = __importDefault(require(\"./useRefresh\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst actionCreator_1 = require(\"../actionCreator\");\nconst usePOWO_1 = __importDefault(require(\"./usePOWO\"));\nconst useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\nconst useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\nconst useCivicPass_1 = __importDefault(require(\"./useCivicPass\"));\nconst useCivicPassEventListener_1 = __importDefault(require(\"./useCivicPassEventListener\"));\nconst status_1 = require(\"../utils/status\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\nconst useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const { gatewayToken, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, gatekeeperNetworkAddress, ownerSigns, renderIframe, refreshTimeoutId, } = state;\n    const networkConfig = (0, networkConfig_1.default)({ gatekeeperNetworkAddress, stage });\n    // Register our hooks here\n    const { waitForConfirmPOWO, waitForPOWO, waitForTransactionConfirm, waitForHandleTransaction } = (0, usePOWO_1.default)({ wallet, chainImplementation }, state, dispatch);\n    const gatekeeperEndpoint = chainImplementation.httpConfig.baseUrl;\n    const { waitForGatekeeperIssuanceRequest } = (0, useGatekeeper_1.default)({ wallet, stage, gatekeeperClient }, state, dispatch);\n    const { checkForRefreshWithTimeout, refreshToken, waitForUnexpiredGatewayToken } = (0, useRefresh_1.default)({ stage, gatekeeperClient, networkConfig }, state, dispatch);\n    (0, useCivicPass_1.default)({ wallet }, state, dispatch);\n    (0, useCivicPassEventListener_1.default)({ wallet, chainImplementation });\n    (0, useChain_1.default)({ wallet, chainImplementation, networkConfig }, state, dispatch);\n    (0, useGatekeeperRecord_1.default)({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig, networkConfig }, state, dispatch);\n    /**\n     * Refresh Flows ----------------------------------------------------------------\n     */\n    /**\n     * wait until we have a payload that has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n            logger_1.default.debug('Refresh payload...', {\n                refreshPayload,\n                refreshPayloadState: refreshPayload === undefined,\n            });\n            if (refreshPayload !== undefined) {\n                logger_1.default.debug('Refreshing token...');\n                resolve(refreshPayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * When we have a token start check the next expiration so we can prompt the user to refresh\n     */\n    (0, react_1.useEffect)(() => {\n        logger_1.default.debug('useOrchestration', {\n            gatewayStatus: gatewayStatus && (0, status_1.statusDisplayValue)(gatewayStatus),\n            refreshTokenState: refreshTokenState && types_1.RefreshTokenState[refreshTokenState],\n        });\n        if (gatewayStatus === types_1.GatewayStatus.ACTIVE || refreshTokenState === types_1.RefreshTokenState.COMPLETED) {\n            logger_1.default.debug('Start polling for the refresh interval');\n            checkForRefreshWithTimeout(wallet);\n        }\n    }, [gatewayStatus, refreshTokenState, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, renderIframe]);\n    /**\n     * Whenever the iFrame is rendered, clear the timeout\n     */\n    (0, react_1.useEffect)(() => {\n        if (renderIframe && refreshTimeoutId) {\n            logger_1.default.debug('useEffect:dispatch refresh_clear_timeout');\n            clearTimeout(refreshTimeoutId);\n            dispatch({ type: 'refresh_clear_timeout' });\n        }\n    }, [renderIframe, refreshTimeoutId]);\n    /**\n     * Issuance Flows ----------------------------------------------------------------\n     */\n    /**\n     * poll until a gatekeeper record is found, once active check the chain for a token\n     * then dispatch a tokenChange event that will result in the token getting saved to state\n     * start token refresh polling once a valid token is set\n     */\n    const waitForOnChainToken = (0, react_1.useCallback)(async () => {\n        if (wallet) {\n            logger_1.default.debug('waitForOnChainToken');\n            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n                wallet,\n                chainImplementation,\n                gatekeeperClient,\n                dispatch,\n                networkConfig,\n                ownerSigns,\n            });\n            await actionCreator.waitForGatewayToken();\n        }\n        return null;\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n    /**\n     * wait until a presentation request id has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n            logger_1.default.debug('Issuance payload...', issuancePayload);\n            if (issuancePayload !== undefined) {\n                resolve(issuancePayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * wait until the user has requested a gateway token before resolving the promise\n     */\n    const checkForRequiredProof = (0, react_1.useCallback)(async ({ requiresProofOfWalletOwnership, payload, }) => {\n        logger_1.default.debug('Checking for required proof', { requiresProofOfWalletOwnership, payload });\n        if (requiresProofOfWalletOwnership) {\n            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n            return result;\n        }\n        return { payload };\n    }, [waitForConfirmPOWO, waitForPOWO]);\n    /**\n     * New token request flow !ownerSigns:\n     * wait for the user to request a new token\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to request a new token issuance\n     * wait for a gatekeeper record to be created\n     * once this flow is complete a new Gatekeeper token should be available and set in state\n     */\n    (0, react_1.useEffect)(() => {\n        if (!ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload !ownerSigns');\n            waitForCivicPassIssuanceResponsePayload()\n                .then(checkForRequiredProof)\n                .then(waitForGatekeeperIssuanceRequest)\n                .then(waitForOnChainToken)\n                .then(() => checkForRefreshWithTimeout(wallet))\n                .catch((error) => {\n                dispatch({ type: 'civicPass_issuance_failure' });\n                logger_1.default.error('ERROR newTokenRequestFlow', error);\n            });\n        }\n    }, [\n        waitForCivicPassIssuanceResponsePayload,\n        checkForRequiredProof,\n        waitForGatekeeperIssuanceRequest,\n        waitForOnChainToken,\n        ownerSigns,\n    ]);\n    /** Wrapper to pass through expected parameters when waiting for owner signs confirmation */\n    const confirmOwnerTransaction = (0, react_1.useCallback)(async ({ payload }) => {\n        await waitForTransactionConfirm();\n        return { payload };\n    }, [waitForTransactionConfirm]);\n    /**\n     * Trigger the waiting for owner transaction state\n     * this function is a promise so it can be thenable\n     */\n    const showAwaitingOwnerTransaction = async () => {\n        logger_1.default.debug('showAwaitingOwnerTransaction');\n        dispatch({ type: 'civicPass_awaiting_owner_transaction' });\n        return Promise.resolve();\n    };\n    /**\n     * New token request flow ownerSigns:\n     * wait for the user to request a new token\n     * wait for the iframe to return a payload\n     * wait for the user to confirm the transaction that they need to sign\n     * wait for a call to the gatekeeper to request a new token issuance\n     * wait for the handle transaction callback\n     * wait for a gatekeeper record to be created on chain\n     * once this flow is complete a new Gatekeeper token should be available and set in state\n     */\n    (0, react_1.useEffect)(() => {\n        if (ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload ownerSigns');\n            waitForCivicPassIssuanceResponsePayload()\n                .then(confirmOwnerTransaction)\n                .then(waitForGatekeeperIssuanceRequest)\n                .then(waitForHandleTransaction)\n                .then(showAwaitingOwnerTransaction)\n                .then(waitForOnChainToken)\n                .then(() => checkForRefreshWithTimeout(wallet))\n                .catch((error) => {\n                // chain transaction errors will be handled using a different flow and dispatch event\n                if (!(error instanceof types_1.ChainTransactionError)) {\n                    dispatch({ type: 'civicPass_issuance_failure' });\n                }\n                logger_1.default.error('ERROR newTokenRequestFlow', error);\n            });\n        }\n    }, [\n        waitForCivicPassIssuanceResponsePayload,\n        confirmOwnerTransaction,\n        waitForGatekeeperIssuanceRequest,\n        waitForHandleTransaction,\n        waitForOnChainToken,\n        ownerSigns,\n    ]);\n    /**\n     * Refresh start flow !ownerSigns:\n     * Triggered when we have a refreshResponse payload\n     * wait refresh to be triggered from the iFrame\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to refresh the token\n     * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n     */\n    (0, react_1.useEffect)(() => {\n        if (!ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload !ownerSigns');\n            const useWallet = walletToRefresh || wallet;\n            waitForCivicPassRefreshResponsePayload()\n                .then(checkForRequiredProof)\n                .then(refreshToken(useWallet))\n                .then(() => dispatch({ type: 'refresh_token_success' }))\n                .catch((error) => {\n                logger_1.default.error('refreshFlow', error);\n                dispatch({ type: 'civicPass_refresh_failure' });\n            });\n        }\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, ownerSigns]);\n    /**\n     * Refresh start flow ownerSigns:\n     * Triggered when we have a refreshResponse payload\n     * wait refresh to be triggered from the iFrame\n     * wait for the iframe to return a payload\n     * wait for the handle transaction callback\n     * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n     */\n    (0, react_1.useEffect)(() => {\n        if (ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload ownerSigns');\n            const useWallet = walletToRefresh || wallet;\n            waitForCivicPassRefreshResponsePayload()\n                .then(refreshToken(useWallet))\n                .then(waitForHandleTransaction)\n                .then(() => dispatch({ type: 'refresh_token_success' }))\n                .catch((error) => {\n                // chain transaction errors will be handled using a different flow and dispatch event\n                if (!(error instanceof types_1.ChainTransactionError)) {\n                    dispatch({ type: 'civicPass_refresh_failure' });\n                }\n                logger_1.default.error('ERROR tokenRefreshFlow ownerSigns', error);\n            });\n        }\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, ownerSigns]);\n    /**\n     * Refresh complete flow:\n     * Triggered by token change event triggered from a call to the gatekeeper to refresh the token\n     * for owner signs case, dispatch an event to show the iframe chain-transaction confirming screen\n     * wait until the token is unexpired and clear timeout if token is not expired\n     * Complete the refresh event and clear the refresh response payload\n     */\n    (0, react_1.useEffect)(() => {\n        const useWallet = walletToRefresh || wallet;\n        if (refreshTokenState === types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN) {\n            logger_1.default.debug('useEffect: Refresh complete flow', {\n                expiryTime: gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,\n                hasExpired: (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) ? (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime) : 'unknown',\n            });\n            // if the dApp handles the transaction we shouldn't assume that the final state is 'unexpired' token\n            const optionalCheckUnexpired = chainImplementation.dAppHandlesTransactions && ownerSigns\n                ? () => Promise.resolve()\n                : waitForUnexpiredGatewayToken;\n            optionalCheckUnexpired()\n                .then(() => checkForRefreshWithTimeout(useWallet))\n                .then(() => {\n                dispatch({ type: 'refresh_complete' });\n                dispatch({ type: 'civicPass_check_token_status' });\n            })\n                .catch((error) => {\n                logger_1.default.error('refreshFlow', error);\n                dispatch({ type: 'civicPass_refresh_failure' });\n            });\n        }\n    }, [\n        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier,\n        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,\n        refreshTokenState,\n        walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey,\n        wallet === null || wallet === void 0 ? void 0 : wallet.publicKey,\n        ownerSigns,\n    ]);\n};\nexports.default = useOrchestration;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}